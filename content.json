{"meta":{"title":"텅 빈 충만의 블로그","subtitle":"Ruby JavaScript Scheme을 사랑하는 초보 학생의 소박한 프로그래밍.","description":"즐거운 프로그래밍 세상, Hello World!","author":"텅 빈 충만(voidSatisfaction)","url":"https://voidsatisfaction.github.io"},"pages":[],"posts":[{"title":"AWS DynamoDB 정리 1부 테이블 만들기, 테이블 정보보기, 데이터 읽기","slug":"aws-dynamodb-study","date":"2016-12-10T11:56:07.000Z","updated":"2016-12-11T06:18:15.000Z","comments":true,"path":"2016/12/10/aws-dynamodb-study/","link":"","permalink":"https://voidsatisfaction.github.io/2016/12/10/aws-dynamodb-study/","excerpt":"","text":"참조 Amazon DynamoDB 사용 방법 배경드디어 나와 사부가 만들던 어플리케이션에서 서버 부분까지 내가 담당해 보기로 했다. 사부는 nodejs와 aws dynamodb로 서버를 개발하고 있었는데 나도 처음으로 그 부분에 대해서 공부하게 되었다. 그런데 이제까지는 mysql정도 밖에 다루어 보지 않았어서 aws dynamodb는 정말 생소하였다. 그래서 이 포스트를 남겨 앞으로 dynamodb를 쓸 때 참고를 하고자 한다. 핵심 primaryKey에는 partitionKey와 sortKey로 나누어져있다.(paritionKey만 있는 경우도 있음.) partitionKey는 겹치더라도, sortKey는 겹치지 않는다. 기본 내용Create a Table1234567891011121314151617181920212223// setting dynamo db tablevar params = &#123; TableName : \"Music\", KeySchema: [ &#123; AttributeName: \"Artist\", KeyType: \"HASH\" &#125;, //Partition key &#123; AttributeName: \"SongTitle\", KeyType: \"RANGE\" &#125; //Sort key ], AttributeDefinitions: [ &#123; AttributeName: \"Artist\", AttributeType: \"S\" &#125;, &#123; AttributeName: \"SongTitle\", AttributeType: \"S\" &#125; ], ProvisionedThroughput: &#123; ReadCapacityUnits: 1, WriteCapacityUnits: 1 &#125;&#125;;dynamodb.createTable(params, function(err, data) &#123; if (err) console.log(JSON.stringify(err, null, 2)); else console.log(JSON.stringify(data, null, 2));&#125;); The params object holds the parameters for the corresponding DynamoDB API operation. The dynamodb. line invokes the operation, with the correct parameters. In the example above, the operation is createTable. Get Information About Tables123456789101112131415161718192021// Retrieve a Table Descriptionvar params = &#123; TableName: \"Music\"&#125;;dynamodb.describeTable(params, function(err, data) &#123; if (err) console.log(JSON.stringify(err, null, 2)); else console.log(JSON.stringify(data, null, 2));&#125;);// Retrieve a List of Tablesvar params = &#123;&#125;;dynamodb.listTables(params, function(err, data) &#123; if (err) console.log(JSON.stringify(err, null, 2)); else console.log(JSON.stringify(data, null, 2));&#125;); Write Items to the Table12345678910111213141516171819202122// Write a Itemvar params = &#123; TableName: \"Music\", Item: &#123; \"Artist\":\"No One You Know\", \"SongTitle\":\"Call Me Today\", \"AlbumTitle\":\"Somewhat Famous\", \"Year\": 2015, \"Price\": 2.14, \"Genre\": \"Country\", \"Tags\": &#123; \"Composers\": [ \"Smith\", \"Jones\", \"Davis\" ], \"LengthInSeconds\": 214 &#125; &#125; // Writing succeed only when it satisfy the ConditionExpression's content. if not, it simply overwrite. // \"ConditionExpression\": \"attribute_not_exists(Artist) and attribute_not_exists(SongTitle)\"&#125;; Artist and SongTitle are primary key attributes (partition key and sort key, respectively). Both are of string type. Every item that you add to the table must have values for these attributes. Other attributes are AlbumTitle (string), Year (number), Price (number), Genre (string), and Tags (map). DynamoDB allows you to nest attributes within other attributes. The Tags map contains two nested attributes—Composers (list) and LengthInSeconds (number). Artist, SongTitle, AlbumTitle, Year, Price, Genre, and Tags are top-level attributes because they are not nested within any other attributes. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Write Multiple Itemsvar params = &#123; RequestItems: &#123; \"Music\": [ &#123; PutRequest: &#123; Item: &#123; \"Artist\": \"No One You Know\", \"SongTitle\": \"My Dog Spot\", \"AlbumTitle\":\"Hey Now\", \"Price\": 1.98, \"Genre\": \"Country\", \"CriticRating\": 8.4 &#125; &#125; &#125;, &#123; PutRequest: &#123; Item: &#123; \"Artist\": \"No One You Know\", \"SongTitle\": \"Somewhere Down The Road\", \"AlbumTitle\":\"Somewhat Famous\", \"Genre\": \"Country\", \"CriticRating\": 8.4, \"Year\": 1984 &#125; &#125; &#125;, &#123; PutRequest: &#123; Item: &#123; \"Artist\": \"The Acme Band\", \"SongTitle\": \"Still In Love\", \"AlbumTitle\":\"The Buck Starts Here\", \"Price\": 2.47, \"Genre\": \"Rock\", \"PromotionInfo\": &#123; \"RadioStationsPlaying\":[ \"KHCR\", \"KBQX\", \"WTNR\", \"WJJH\" ], \"TourDates\": &#123; \"Seattle\": \"20150625\", \"Cleveland\": \"20150630\" &#125;, \"Rotation\": \"Heavy\" &#125; &#125; &#125; &#125;, &#123; PutRequest: &#123; Item: &#123; \"Artist\": \"The Acme Band\", \"SongTitle\": \"Look Out, World\", \"AlbumTitle\":\"The Buck Starts Here\", \"Price\": 0.99, \"Genre\": \"Rock\" &#125; &#125; &#125; ] &#125;&#125;;docClient.batchWrite(params, function (err, data) &#123; if (err) console.log(JSON.stringify(err, null, 2)); else console.log(JSON.stringify(data, null, 2));&#125;); Read an Item Using Its Primary Key123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// Read an Item Using GetItemvar params = &#123; TableName: \"Music\", Key: &#123; \"Artist\": \"No One You Know\", \"SongTitle\": \"Call Me Today\" &#125;&#125;;docClient.get(params, function(err, data) &#123; if (err) console.log(JSON.stringify(err, null, 2)); else console.log(JSON.stringify(data, null, 2));&#125;);//// Result : It is very different from get multiple datas using batchGet api.&#123; \"Item\": &#123; \"Artist\": \"No One You Know\", \"Year\": 2015, \"Price\": 2.14, \"SongTitle\": \"Call Me Today\", \"AlbumTitle\": \"Somewhat Famous\", \"Genre\": \"Country\", \"Tags\": &#123; \"Composers\": [ \"Smith\", \"Jones\", \"Davis\" ], \"LengthInSeconds\": 214 &#125; &#125;&#125;// only Read an item's subset of attributesvar params = &#123; TableName: \"Music\", Key: &#123; \"Artist\": \"No One You Know\", \"SongTitle\": \"Call Me Today\" &#125;, ProjectionExpression: \"AlbumTitle\"&#125;;// when it comes to Reserved word (Year)var params = &#123; TableName: \"Music\", Key: &#123; \"Artist\": \"No One You Know\", \"SongTitle\": \"Call Me Today\" &#125;, ProjectionExpression: \"AlbumTitle, #y\", // #y is placeholder token ExpressionAttributeNames: &#123;\"#y\": \"Year\"&#125;&#125;;// Read maps / list datavar params = &#123; TableName: \"Music\", Key: &#123; \"Artist\": \"No One You Know\", \"SongTitle\": \"Call Me Today\" &#125;, ProjectionExpression: \"AlbumTitle, #y, Tags.Composers[0], Tags.LengthInSeconds\", ExpressionAttributeNames: &#123;\"#y\": \"Year\"&#125;&#125;;// Read multiple itemsvar params = &#123; RequestItems: &#123; \"Music\": &#123; Keys: [ &#123; \"Artist\": \"No One You Know\", \"SongTitle\": \"My Dog Spot\" &#125;, &#123; \"Artist\": \"No One You Know\", \"SongTitle\": \"Somewhere Down The Road\" &#125;, &#123; \"Artist\": \"The Acme Band\", \"SongTitle\": \"Still In Love\" &#125;, &#123; \"Artist\": \"The Acme Band\", \"SongTitle\": \"Look Out, World\" &#125; ], &#125; &#125;&#125;;docClient.batchGet(params, function (err, data) &#123; if (err) console.log(JSON.stringify(err, null, 2)); else console.log(JSON.stringify(data, null, 2));&#125;);// Result&#123; \"Responses\": &#123; \"Music\": [ &#123; \"Artist\": \"The Acme Band\", \"PromotionInfo\": &#123; \"TourDates\": &#123; \"Seattle\": \"20150625\", \"Cleveland\": \"20150630\" &#125;, \"Rotation\": \"Heavy\", \"RadioStationsPlaying\": [ \"KHCR\", \"KBQX\", \"WTNR\", \"WJJH\" ] &#125;, \"AlbumTitle\": \"The Buck Starts Here\", \"Genre\": \"Rock\", \"Price\": 2.47, \"SongTitle\": \"Still In Love\" &#125;, &#123; \"Artist\": \"No One You Know\", \"AlbumTitle\": \"Somewhat Famous\", \"Genre\": \"Country\", \"Year\": 1984, \"SongTitle\": \"Somewhere Down The Road\", \"CriticRating\": 8.4 &#125;, &#123; \"Artist\": \"The Acme Band\", \"AlbumTitle\": \"The Buck Starts Here\", \"Genre\": \"Rock\", \"Price\": 0.99, \"SongTitle\": \"Look Out, World\" &#125;, &#123; \"Artist\": \"No One You Know\", \"AlbumTitle\": \"Hey Now\", \"Genre\": \"Country\", \"Price\": 1.98, \"SongTitle\": \"My Dog Spot\", \"CriticRating\": 8.4 &#125; ] &#125;, \"UnprocessedKeys\": &#123;&#125;&#125; 정리To be continued…","categories":[{"name":"Database","slug":"Database","permalink":"https://voidsatisfaction.github.io/categories/Database/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://voidsatisfaction.github.io/tags/Database/"},{"name":"Dynamodb","slug":"Dynamodb","permalink":"https://voidsatisfaction.github.io/tags/Dynamodb/"}],"keywords":[{"name":"Database","slug":"Database","permalink":"https://voidsatisfaction.github.io/categories/Database/"}]},{"title":"PropTypes과 Semantic Commit Messages","slug":"propTypes-and-sementic","date":"2016-12-07T06:28:03.000Z","updated":"2016-12-07T06:49:18.000Z","comments":true,"path":"2016/12/07/propTypes-and-sementic/","link":"","permalink":"https://voidsatisfaction.github.io/2016/12/07/propTypes-and-sementic/","excerpt":"","text":"참조 React.jsのProp KARMA Git Commit Msg Semantic Commit Message 배경사부의 커밋 메세지를 보면 feat:, fix: 이런 것들이 붙어져 있어서 그것에 대한 유래를 물어보았다. 그리고 전부터 대충은 알고 있던 React Native의 PropTypes에 대해서 한 번은 정리할 필요가 있을 것 같아서 포스팅을 하게 되었다. 핵심Semantic Commit Message Examples chore: add Oyster build script (oyster build가 뭐죠? 아시는 분 알려주세요!) docs: explain hat wobble feat: add beta sequence fix: remove broken confirmation Message refactor: share logic between a and b style: convert tabs to spaces … (and so on) test: ensure Tayne retains clothing PropTypesPropTypes는 Component의 외부로부터 받아온 prop을 validation하기 위해서 prop의 type을 명시적으로 제한한다. 1234567891011121314151617181920212223242526React.PropTypes.array // 配列React.PropTypes.bool.isRequired // Booleanで必須React.PropTypes.func // 関数React.PropTypes.number // 数値React.PropTypes.object // オブジェクトReact.PropTypes.string // 文字列React.PropTypes.node // RenderできるものReact.PropTypes.element // React ElementReact.PropTypes.instanceOf(XXX) // XXXのinstanceかどうかReact.PropTypes.oneOf(['foo', 'bar']) // fooかbarReact.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.array]) // 文字列か配列React.PropTypes.arrayOf(React.PropTypes.string) // 文字列の配列かどうかReact.PropTypes.objectOf(React.PropTypes.string) // 文字列の値を持っているかReact.PropTypes.shape(&#123; // 指定された形式を満たしているかどうか color: React.PropTypes.string, fontSize: React.PropTypes.number&#125;);React.PropTypes.any.isRequired // なんでもいいけど必須// カスタムの制約も定義出来る(ダメな場合はError投げる)customPropType: function(props, propName, componentName) &#123; if (!/^[0-9]/.test(props[propName])) &#123; return new Error('Validation failed!'); &#125;&#125; 위와 같은 종류의 PropTypes를 이용할 수 있다. 정리 프로그래밍의 세계에서는 알기 쉬운게 최고다! 나를 배려하고 나와 협업하는 동료를 배려하자.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://voidsatisfaction.github.io/tags/GitHub/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"High Order Component에 대하여","slug":"high-order-component","date":"2016-12-06T14:06:58.000Z","updated":"2016-12-06T14:59:26.000Z","comments":true,"path":"2016/12/06/high-order-component/","link":"","permalink":"https://voidsatisfaction.github.io/2016/12/06/high-order-component/","excerpt":"","text":"참조 recompose 배경1234567// setFormState setFormState(name, value) &#123; this.setState(&#123; [name]: value, &#125;);&#125; 위와 같은 setFormState가 smart컴포넌트를 변경하는 거의 모든 경우에서 중복되어서 사용되기 때문에 재활용성을 높이고 render수를 줄이므로써 효율성을 높이고 데이터 구조를 보다 명시적으로 나타내기 위해서 highOrderComponent를 새로 구성하기로 했다. 핵심123456789101112131415161718192021222324252627282930313233// from '../../_hocs/setFormState';import React, &#123; Component &#125; from 'react';interface config &#123; (props: Object): configForms&#125;interface configForms &#123; forms: Object&#125;export default setFormState = (config: config | configForms) =&gt; (BaseComponent: Comment) =&gt; ( class extends Component &#123; constructor(props) &#123; super(props); this.setFormState = this.setFormState.bind(this); if (typeof config === 'function') &#123; this.state = config(props).forms; &#125; else if (typeof config === 'object') &#123; this.state = config.forms; &#125; &#125; setFormState(name, value) &#123; this.setState(&#123; [name]: value, &#125;); &#125; render() &#123; return &lt;BaseComponent setFormState=&#123;this.setFormState&#125; forms=&#123;this.state&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;); 기본 내용interface가장 먼저, interface와 관련된 내용이 나오는데 interface는 typeScript와 관련된 문법이다.(RN자체적으로 일부 typeScript문법을 지원해주는 것인지, 아니면 babel과 관련된것인지는 아직 확인 되지 않음) c.f) TypeScript 위의 interface config 이것은, config라는 데이터의 형태를 보기 좋게 정의한 것이다. (처음 봤을때에는 c++에서 변수나 함수의 타입을 미리 정의하는것과 같다는 느낌이 들었다.) 즉, config라는 데이터는, 함수이며 인수로는 object를 받고 결과값은 configForms를 따른다는 것이다. 마찬가지로 configForms라는 데이터는, object이며, forms라는 속성을 갖고 그 속성의 값도 object라는 의미이다. setFormState이 부분이 어려우니 차근차근 생각해야한다. 먼저 우리는 setFormState라는 함수를 export할 것인데 이 함수는 먼저 config라는 하나의 인자를 받고 이 인자는 앞서 interface에 정의한 config의 형태이거나 configForms의 형태이다. 이 함수는 함수를 리턴하는데(lamda) 리턴하는 함수는 인자로서 Comment형을 가진 BaseComponent라는 데이터이다. 이 함수는 하나의 이름이 없는 class를 리턴한다. 그 이름없는 class는 클로저 변수인 config의 type에 따라서 행위를 규정하고, setFormState를 bind하고 마지막으로는 BaseComponent에 setFormState, Forms, this.props(Redux등으로 받은 props)를 넘겨준다. 정리이렇게 하면, setFormState의 중복을 해결할 수 있고 staticForm이라는 데이터를 setFormState함수의 인수에 추가하고 React Lifecycle인 shouldComponentUpdate()함수를 이용하여 render의 수를 줄일 수 있을것이다. 그리고 baseComponent에 사용되는 data를 타입과 함께 명시할 수 있는것도 크나큰 메리트이다. Special Thanks to JavaScript Goodparts 더글라스 크락포드 선생님!","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"사부와 함께하는 Promise 이해하기","slug":"javascript-promise-practice-with-cheol","date":"2016-11-19T05:12:39.000Z","updated":"2016-11-20T06:38:31.000Z","comments":true,"path":"2016/11/19/javascript-promise-practice-with-cheol/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/19/javascript-promise-practice-with-cheol/","excerpt":"","text":"배경Nodejs 비동기 프로그래밍 환경에서 정말 중요한 Promise가 헷갈려서 사부에게 도움을 청했다. 그래서 다음과 같은 코드를 받았다. 그리고 그 밑은 나의 해석. 핵심 Nodejs는 모든 scope에서 비동기적인 io 매커니즘을 가지고 있다. Promise는 그 자체가 객체로서, resolve() 나 reject() 를 호출하게 하므로서, 함수 내의 모든 실행이 해결된 것을 나타낸다. 따라서, Promise객체의 return으로 동기적인 함수 실행을 이어나갈 수 있다.(콜백함수 효과) Promise객체의 return이 없다면 뒤에 붙는 then자체는 사실상 의미가 없다. NodeJS의 비동기 처리 tick이 달라지는 계기를 주는 이벤트가 생기면 그래야지 그것이 event loop에 들어가게 되고 나머지 같은 틱에 있는 처리들은 동기적으로 한다그리고 같은 틱의 처리가 끝나면 event loop에 있는 것들도 마찬가지로 한다. 같은 틱에서는 동기적으로 프로그램이 동작하고틱과 틱 사이에서도 동기적으로 프로그램이 동작한다. one-tick에 같이 실행됨 -&gt; 동기one-tick에 실행이 안되고, event에 의해서 다른 tick에서 실행이 됨 -&gt; 비동기 123456function wow (text, cb) &#123; cb(text+ 'wow') console.log('hi world!') &#125; wow('abc', (wowText) =&gt; console.log(wowText)) console.log(1) 이 예에서는 콜백이어도 같은 틱에서 처리하니까 콜백을 먼저함 동기적으로 Promise 기본 내용 promise_test1.js - g6ling promise_test2.js - g6ling promise_test3.js - g6ling promise_test4.js - g6ling Promise 실행순서 이해하기 - g6ling Promise - MDN Promise.prototype.then() - MDN 참고 내용 Callbacks, Promises, and Coroutines p.s 이 슬라이드는 35,36에 오류가 있다. 그 내용은 댓글에서 확인. Node.js - Definitive Design Definition - Tutorial Series #0 발전12345678910111213141516171819202122232425var f1 = function () &#123; setTimeout(function()&#123; console.log(\"f1\", \"First function call...\"); &#125;, 0);&#125;;var f2 = function () &#123; console.log(\"f2\", \"Second call...\");&#125;;f1(); f2();// f2 Second call...// f1 First function call...// 일단 위의 프로그램이 실행되면// first-tick일때(즉, 호출하자마자)f1, f2가 각각실행된다.(같은 tick에서는 동기)// 근데 f1에서는 setTimeout이라는 함수가 있으므로 event loop위에 올려놓는다.// 하지만 f2는 console.log만 존재하므로 그것을 실행한다.// second-tick일때는 0초뒤의 경우(setTimeout에서 0이 지정되었으므로)이므로 // event loop위에 올려놓았던 setTimeout의 내용을 실행한다.// 그것은 console.log()이므로// 그대로 출력한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}]},{"title":"내가 생각하는 해달의 매력 팡팡","slug":"fighting-haedal-love","date":"2016-11-19T04:15:31.000Z","updated":"2016-11-19T04:41:32.000Z","comments":true,"path":"2016/11/19/fighting-haedal-love/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/19/fighting-haedal-love/","excerpt":"","text":"내가 생각하는 나만의 해달의 매력 진심으로 오빠를 생각해준다. 볼이 빵빵하다. 화나도 귀엽다. 울어도 귀엽다. 질투해도 귀엽다. 살쪄도 귀엽다. 과자를 너무나도 맛있게 만들어준다. 매일밤 같이 얘기하면 너무나도 즐겁다. 고기를 너무 잘 먹는다. 나중에 나에게 코딩을 가르쳐주겠지? 보기만해도 좋다. 다좋다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"Haedal","slug":"Haedal","permalink":"https://voidsatisfaction.github.io/tags/Haedal/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"My Todo list (2016.11.16)","slug":"check-read-todo","date":"2016-11-16T11:16:32.000Z","updated":"2016-11-19T11:59:37.000Z","comments":true,"path":"2016/11/16/check-read-todo/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/16/check-read-todo/","excerpt":"","text":"JavaScript 기술 훑어보기 Vue.js Next.js Phantom.js Moment.js apisauce JavaScript 지식 Nodejs Node.js - Wikipedia Node.js - Definitive Design Definition - Tutorial Series #0 Nodejs eventloop What the hexk is the event loop anyway? - youtube eventloop? - stack overflow Asynchronous programming on Nodejs Asynchronous Iterative &amp; Recursive Patterns for Node.js [JavaScript]바보들을 위한 Promise 강의 Promise.prototype.then Understanding JavaScript’s async await Nodejs slack bot Node.jsでSlack botを作る 인턴 リクナビ Infra mynavi キャリアバイト","categories":[{"name":"Todo","slug":"Todo","permalink":"https://voidsatisfaction.github.io/categories/Todo/"}],"tags":[{"name":"Todo","slug":"Todo","permalink":"https://voidsatisfaction.github.io/tags/Todo/"}],"keywords":[{"name":"Todo","slug":"Todo","permalink":"https://voidsatisfaction.github.io/categories/Todo/"}]},{"title":"2016년에 자바스크립트를 배우는 기분(스크랩)","slug":"how-it-feels-to-learn-javascript-in-2016","date":"2016-11-16T05:58:41.000Z","updated":"2016-11-16T06:31:43.000Z","comments":true,"path":"2016/11/16/how-it-feels-to-learn-javascript-in-2016/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/16/how-it-feels-to-learn-javascript-in-2016/","excerpt":"","text":"출처How it feels to learn JavaScript in 2016 - 번역 키워드내용How it feels to learn JavaScript in 20162016년에 자바스크립트를 배우는 기분 Edit: Thanks for pointing typos and mistakes, I’ll update the article as noted. Discussion in HackerNews and Reddit. 수정: 오타와 실수를 지적해줘서 고맙당. 말했던 대로 문서를 갱신할께. 토론은 해커뉴스랑 레딧에서. The following is inspired by the article “It’s the future” from Circle CI. You can read the original here. This piece is just an opinion, and like any JavaScript framework, it shouldn’t be taken too seriously. No JavaScript frameworks were created during the writing of this article. 이건 Circle CI의 “It’s the future”에서 영감을 받아 작성된 글이야. 원본은 요기에서 읽을 수 있어. 그냥 자바스크립트 프레임워크에 대한 의견일 뿐이니까 넘 심각하게 받아들이진 말아줘. 적어도 이 글을 쓰는 동안은 새로운 자바스크립트 프레임워크가 나오진 않았어 ㅋㅋㅋ Hey, I got this new web project, but to be honest I haven’t coded much web in a few years and I’ve heard the landscape changed a bit. You are the most up-to date web dev around here right? 야, 내가 새로운 웹 프로젝트를 받았거든, 근데 솔직히 내가 몇 년 동안 웹 코딩을 안했더니 뭐가 어떻게 달라졌는지 잘 모르겠어. 네가 요즘 웹 굴러가는 걸 좀 알고 있지? 좀 털어봐. The actual term is Front End engineer, but yeah, I’m the right guy. I do web in 2016. Visualisations, music players, flying drones that play football, you name it. I just came back from JsConf and ReactConf, so I know the latest technologies to create web apps. 뭐 제대로 얘기하자면 프론트엔드 엔지니어겠지만, 뭐 대충 그래, 맞아. 난 2016년에 웹을 하고 있지. 시각화, 음악 재생기, 축구 경기를 하는 날아다니는 드론이라든가. 마침 JsConf랑 ReactConf에서 막 돌아온 참이라 웹 앱을 만드는 최신 기술들을 알고 있다고 볼 수 있지. Cool. I need to create a page that displays the latest activity from the users, so I just need to get the data from the REST endpoint and display it in some sort of filterable table, and update it if anything changes in the server. I was thinking maybe using jQuery to fetch and display the data? 쩐다. 난 지금 사용자들이 남긴 최근 행동들을 보여주는 페이지를 짜려고 하는데, 그러면 일단 REST를 이용해서 데이터를 불러와 필터가 되는 테이블에 표시해 준 다음, 서버에서 갱신되는 게 있다면 테이블을 업데이트 해주려고 해. 데이터 불러오고 표시하는 데 jQuery 쓰면 되지? Oh my god no, no one uses jQuery anymore. You should try learning React, it’s 2016. 야잌ㅋㅋㅋㅋ 누가 jQuery 쓴다고 그러냐. 2016년 잇 아이템인 React를 써야지. Oh, OK. What’s React? 헐, 그게 뭔데? It’s a super cool library made by some guys at Facebook, it really brings control and performance to your application, by allowing you to handle any view changes very easily. 페이스북 존잘러들이 만든 슈퍼쿨 짱짱 라이브러리지. 네가 웹앱 만들 때 뷰를 마음대로 다루면서 기능과 성능도 모두 챙길 수 있지. That sounds neat. Can I use React to display data from the server? 쩐다… React 써서 서버에서 온 데이터도 표시할 수 있지? Yeah, but first you need to add React and React DOM as a library in your webpage. 당근, 근데 일단 React랑 React DOM을 니 웹 페이지에 넣어야 됨. Wait, why two libraries? 엥? 왜 두 개나 넣어야 함? So one is the actual library and the second one is for manipulating the DOM, which now you can describe in JSX. 하나는 진짜 라이브러리고 다른 건 DOM 다루는 데 쓰지. 그건 JSX로 표현되는거고. JSX? What is JSX? JSX? 그건 또 뭔데? JSX is just a JavaScript syntax extension that looks pretty much like XML. It’s kind of another way to describe the DOM, think of it as a better HTML. JSX는 자바스크립트 문법을 확장하는 거야 XML처럼. DOM을 표현하는 다른 방식인데 HTML보다 훨 나음. What’s wrong with HTML? HTML 가지고 뭐가 부족하길래 그런 걸 씀? It’s 2016. No one codes HTML directly anymore. 야 2016년에 직접 HTML을 다루는 사람이 어딨어. Right. Anyway, if I add these two libraries then I can use React? 알았어. 그럼 그 둘만 더하면 React 쓸 수 있는거지? Not quite. You need to add Babel, and then you are able to use React. 글쎄, Babel을 추가해야 React를 쓸 수 있을껄. Another library? What’s Babel? Babel은 또 뭐임? Oh, Babel is a transpiler that allows you to target specific versions of JavaScript, while you code in any version of JavaScript. You don’t HAVE to include Babel to use ReactJS, but unless you do, you are stuck with using ES5, and let’s be real, it’s 2016, you should be coding in ES2016+ like the rest of the cool kids do. ㅋㅋ Babel은 자바스크립트를 특정 자바스크립트 버전으로 옮겨주는 녀석(transpiler)이지. ReactJS를 쓰는데 꼭 Babel을 써야할 필요는 없는데 그럼 ES5만 써야 함. 2016년인데 당근 ES2016+ 정도 써야 어디가서 자바스크립트 좀 한다고 볼 수 있지. ES5? ES2016+? I’m getting lost over here. What’s ES5 and ES2016+? ES5? ES2016+? 이게 다 뭔데… 진짜 돌아버리겠음. ES5 stands for ECMAScript 5. It’s the edition that has most people target since it has been implemented by most browsers nowadays. ES5는 ECMAScript 5를 나타내는거야. 요즘 브라우저들에서 구현되어 돌아가고 있는 대부분의 버전이 이거라고 보면 됨. ECMAScript? ECMAScript? Yes, you know, the scripting standard JavaScript was based on in 1999 after its initial release in 1995, back then when JavaScript was named Livescript and only ran in the Netscape Navigator. That was very messy back then, but thankfully now things are very clear and we have, like, 7 editions of this implementation. 엉, 표준이라 불리는 자바스크립트는 1999년에 만들어진 물건이지. 1995년에 처음 제안되기 했는데 그 땐 이름이 Livescript라고 불렸고 넷스케이프 내비게이터에서만 돌아갔어. 그 땐 모든 게 엉망진창이었는데 요즘 그나마 이렇게 된 걸 감사해야지. 아무튼 요즘 돌아가는건 일곱 번째 구현체야. 7 editions. For real. And ES5 and ES2016+ are? 일곱 번째라고. 흠좀무. 그럼 ES5랑 ES2016+는 뭐라고? The fifth and seventh edition respectively. 다섯 번째랑 일곱 번째를 그렇게 부르지. Wait, what happened with the sixth? 여섯 째한텐 도대체 뭔 일이 있었길래… You mean ES6? Yeah, I mean, each edition is a superset of the previous one, so if you are using ES2016+, you are using all the features of the previous versions. ES6 말하는거임? ㅋㅋ 뭐 다 하위호환성을 가지고 있어서 ES2016+을 쓴다면 그 이전 버전의 기능 다 쓰고 있는 거라고 보면 됨. Right. And why use ES2016+ over ES6 then? 알았다… 그럼 ES6 말고 ES2016+는 왜 쓰는데? Well, you COULD use ES6, but to use cool features like async and await, you need to use ES2016+. Otherwise you are stuck with ES6 generators with coroutines to block asynchronous calls for proper control flow. 뭐… 굳이 원한다면 ES6 써도 돼. 근데 async랑 await 같이 멋진걸 쓰려면 ES2016+을 써야만 해. 아니면 ES6 제너레이터로 코루틴만 쓸 수 있을거야. 비동기 호출 흐름을 제어하려면 말이지. &gt; Otherwise you are stuck with ES6 generators with coroutines to block asynchronous calls for proper control flow. 의 보다 정확한 번역이 필요합니다. I have no idea what you just said, and all these names are confusing. Look, I’m just loading a bunch of data from a server, I used to be able to just include jQuery from a CDN and just get the data with AJAX calls, why can’t I just do that? … 뭐라고 하는지 하나도 모르겠는데. 이름도 헷갈리고. 난 그냥 서버에서 데이터 불러서 보여주고 싶은 건데. CDN에서 jQuery 받아서 걍 AJAX 콜 하려는거고. 이렇게 하면 왜 안 되는데? It’s 2016 man, no one uses jQuery anymore, it ends up in a bunch of spaghetti code. Everyone knows that. 2016년이잖아. 아무도 jQuery 같은 건 안 쓴다고. 그런거 썼다간 쓰레기 같은 스파게티 코드만 남아. 그것도 몰라? Right. So my alternative is to load three libraries to fetch data and display a HTML table. 후… 그럼 대안으로 세 가지 라이브러리를 로드하고, 데이터를 받아와서 화면에 HTML 테이블로 뿌리면 되나? Well, you include those three libraries but bundle them up with a module manager to load only one file. 음… 뭐 예전처럼 각각 포함해도 되긴 하는데 가능하면 모듈 매니저를 통해 번들로 묶어서 파일 하나만 로드하는게 낫지. I see. And what’s a module manager? 응. 그럼 모듈 매니저는 또 뭔데? The definition depends on the environment, but in the web we usually mean anything that supports AMD or CommonJS modules. 그건 환경마다 좀 달라. 근데 보통은 AMD나 CommonJS 모듈을 지원하는 걸 말하지. Riiight. And AMD and CommonJS are…? 하………… 그럼 AMD랑 CommonJS는? Definitions. There are ways to describe how multiple JavaScript libraries and classes should interact. You know, exports and requires? You can write multiple JavaScript files defining the AMD or CommonJS API and you can use something like Browserify to bundle them up. 정의, 같은 거지. 이걸 통해서 여러 개의 자바스크립트 라이브러리랑 클래스들과 어떻게 상호 작용할지 설명할 수 있음. exports랑 requires 같은 건 알지? 여러 자바스크립트 파일들을 AMD나 CommonJS API로 정의해 놓으면 Browserify 같은 걸로 묶어서 번들할 수 있음. OK, that makes sense… I think. What is Browserify? 뭐 말은 되네… 근데 또 뭐 Browserify????? It’s a tool that allows you to bundle CommonJS described dependencies to files that can be run in the browser. It was created because most people publish those dependencies in the npm registry. 그건 CommonJS에 정의된 파일들의 의존성을 통해 파일을 묶어서 브라우저에서 실행될 수 있게 해주는 녀석이지. 많은 사람들이 npm 레지스트리에 의존성을 올려뒀기 때문에 생겼어. npm registry? npm 레지스트리??? It’s a very big public repository where smart people put code and dependencies as modules. 존잘러들이 코드랑 의존성을 묶어서 모듈로 배포하는 짱짱 큰 공개 리포지터리 같은 거임. Like a CDN? CDN이랑 비슷한가? Not really. It’s more like a centralised database where anyone can publish and download libraries, so you can use them locally for development and then upload them to a CDN if you want to. 꼭 그런 건 아니지. npm은 라이브러리를 올리고 내려받을 수 있는 중앙 집중형 데이터베이스 같은 건데, 개발 환경에서는 로컬에서 쓸 수 있고 나중에 원하면 CDN에 올려놔도 됨. Oh, like Bower! 아, Bower처럼!! Yes, but it’s 2016 now, no one uses Bower anymore. 응 그치. 근데 2016년에는 아무도 Bower 같은 거 안 씀ㅋㅋㅋ Oh, I see… so I need to download the libraries from npm then? 아이고… 그럼 npm에서 라이브러리 다운로드 받으면 되겠네? Yes. So for instance, if you want to use React , you download the React module and import it in your code. You can do that for almost every popular JavaScript library. 응. 예를 들어서 React를 쓴다고 치자. 그럼 React 모듈을 받아서 니 코드에 임포트 하겠지. 다른 자바스크립트 라이브러리들처럼. Oh, like Angular! 아, Angular처럼! Angular is so 2015. But yes. Angular would be there, alongside VueJS or RxJS and other cool 2016 libraries. Want to learn about those? Angular가 2015년 산이긴 하지만 뭐 암튼 그래. Angular도 VueJS랑 RxJS랑 같이 있을 수 있지. 그 녀석들도 2016년 신상이지. 궁금함? Let’s stick with React, I’m already learning too many things now. So, if I need to use React I fetch it from this npm and then use this Browserify thing? 얔ㅋㅋ React에만 집중하자. 일단 새로 알게된 게 너무 많아 미칠 지경임. 자, 그럼 React를 npm에서 받아서 Browserify로 묶는다? Yes. 이제 좀 알아듣네. That seems overly complicated to just grab a bunch of dependencies and tie them together. 의존성 가진 몇 개를 잡아다가 묶는 것 치고는 좀 심한 거 같은 기분이 드네. It is, that’s why you use a task manager like Grunt or Gulp or Broccoli to automate running Browserify. Heck, you can even use Mimosa. 그래서 말이지, Grunt나 Gulp, Broccoli 같은 태스크 매니저를 써서 Browserify를 자동으로 돌리는거야. ㅋㅋ 아님 Mimosa를 쓰던가. Grunt? Gulp? Broccoli? Mimosa? The heck are we talking about now? Grunt? Gulp? Broccoli? Mimosa? 이 망할 것들은 또 죄다 뭐야? Task managers. But they are not cool anymore. We used them in like, 2015, then we used Makefiles, but now we wrap everything with Webpack. 태스크 매니저야. 근데 더이상 안 써. 2015년에 쓰던 Makefiles 같은 건데 이제는 Webpack이 다 해줘. Makefiles? I thought that was mostly used on C or C++ projects. Makefiles? 그거 C나 C++ 프로젝트할 때 사용해 봤던 것 같은데. Yeah, but apparently in the web we love making things complicated and then going back to the basics. We do that every year or so, just wait for it, we are going to do assembly in the web in a year or two. 어 맞어. 근데 확실한 건 웹 세상에서는 복잡하게 만들었다가 단순하게 돌아가는 것을 좋아하기는 해. We do that every year or so, just wait for it, we are going to do assembly in the web in a year or two. Sigh. You mentioned something called Webpack? 하—… 지금 Webpack이라고 뱉은거지? It’s another module manager for the browser while being kind of a task runner as well. It’s like a better version of Browserify. 그건 브라우저를 위한 모듈 관리자이면서 동시에 태스크 러너 같은 것이기도 하지. Browserify보다 낫던가? Oh, Ok. Why is it better? ㅋㅋ 왜 그게 더 나은데? Well, maybe not better, it’s just more opinionated on how your dependencies should be tied. Webpack allows you to use different module managers, and not only CommonJS ones, so for instance native ES6 supported modules. 음.. 아닐지도 몰라. 니가 어떤 의존성을 가지고 있는지에 따라 좀 호불호가 갈리겠는걸. Webpack은 CommonJS 말고 다른 모듈 관리자를 허용해서 네이티브 ES6 지원 모듈 같은 것도 쓸 수 있지. I’m extremely confused by this whole CommonJS/ES6 thing. 난 지금 CommonJS/ES6 같은 게 헷갈려서 미츄어버리겠는데… Everyone is, but you shouldn’t care anymore with SystemJS. 다들 그래. 하지만 SystemJS는 몰라도 되니까. Jesus christ, another noun-js. Ok, and what is this SystemJS? 하느님 맙소사, 또 뭐시기-js야. 좋아, 그럼 SystemJS는 뭔데? Well, unlike Browserify and Webpack 1.x, SystemJS is a dynamic module loader that allows you to tie multiple modules in multiple files instead of bundling them in one big file. 음… Browserify랑 Webpack 1.x랑은 다르지. SystemJS는 동적 모듈 로더인데 여러 모듈들을 하나의 큰 파일이 대신 여러 파일들로 묶을 수 있게 해주지. Wait, but I thought we wanted to build our libraries in one big file and load that! 잠깐… 아까는 우리가 쓰는 라이브러리들을 하나로 크게 묶어서 한방에 로드한다며! Yes, but because HTTP/2 is coming now multiple HTTP requests are actually better. 응, 그렇지. 근데 HTTP/2가 등장하면 어떨까? 이건 여러 HTTP 요청을 동시에 잘 처리해주거든. Wait, so can’t we just add the three original libraries for React?? 아이고… 그럼 그냥 React 쓰기로 하고 라이브러리 세 개만 넣으면 안 되는거야? Not really. I mean, you could add them as external scripts from a CDN, but you would still need to include Babel then. 음, 내가 말하고 싶은건, CDN을 통해서 외부 스크립트로 추가해도 되는데, 그래도 Babel은 추가해야 할 꺼야. Sigh. And that is bad right? 하……… 그게 나쁘다는거지? Yes, you would be including the entire babel-core, and it wouldn’t be efficient for production. On production you need to perform a series of pre-tasks to get your project ready that make the ritual to summon Satan look like a boiled eggs recipe. You need to minify assets, uglify them, inline css above the fold, defer scripts, as well as- 당근이지. 전체 babel-core를 포함하게 되는데 그게 프로덕션에 환경에서는 효율적이지 않잖아. 프로덕션 환경에서는 사탄을 소환하는 의식이 마치 삶은 계란 조리법처럼 보이도록 일련의 사전 작업들을 수행해서 프로젝트를 준비해야 하거든. 에셋들을 작게 만들고(minify), 못생기게(uglify)한 다음에, 먼저 보일 css는 inline으로 집어넣고 스크립트는 뒤로 빼고.. 뭐 그런 일들… I got it, I got it. So if you wouldn’t include the libraries directly in a CDN, how would you do it? 알았다, 알았어. 그러니까 CDN에서 라이브러리 바로 불러오지 말라는 거잖아. 그럼 넌 어떻게 하는데? I would transpile it from Typescript using a Webpack + SystemJS + Babel combo. 난 보통 Typescript를 Webpack + SystemJS + Babel 콤보로 써서 트랜스파일하지. Typescript? I thought we were coding in JavaScript! 뭐? Typescript? 우리 자바스크립트 얘기하고 있지 않았나???! Typescript IS JavaScript, or better put, a superset of JavaScript, more specifically JavaScript on version ES6. You know, that sixth version we talked about before? Typescript는 자바스크립트이기도 하고 자바스크립트를 포함하기도 하지. 음, 특별히 자바스크립트 ES6의 수퍼셋이라 할 수 있겠다. 아까 말한 여섯 째 기억나지? I thought ES2016+ was already a superset of ES6! WHY we need now this thing called Typescript? 난 ES2016+가 ES6의 수퍼셋이라고 들었는데, 도대체 왜 그걸 Typescript라고 불러야 하는데? Oh, because it allows us to use JavaScript as a typed language, and reduce run-time errors. It’s 2016, you should be adding some types to your JavaScript code. ㅋㅋㅋㅋㅋ 그건 자바스크립트를 타입 언어(typed language)로 쓸 수 있게 해서 런타임의 오류를 줄여주는거야. 봐, 2016년이니까 너도 이제 자바스크립트 코드에 타입을 넣어서 써야지. And Typescript obviously does that. 그러니까 Typescript가 그걸 한다는 거지. Flow as well, although it only checks for typing while Typescript is a superset of JavaScript which needs to be compiled. Flow가 해. 뭐 Typescript가 자바스크립트의 수퍼셋으로 컴파일되어야 할 필요가 있을 때만 검사를 하긴 하지만. Sigh… and Flow is? 이런 미ㅊ… Flow가 뭐? It’s a static type checker made by some guys at Facebook. They coded it in OCaml, because functional programming is awesome. 역시 페북 존잘러들이 만든 정적 타입 분석기야. OCaml으로 만들었지. 역시 함수형 프로그래밍이 짱인듯. OCaml? Functional programming? OCaml? 함수형 프로그래밍? It’s what the cool kids use nowadays man, you know, 2016? Functional programming? High order functions? Currying? Pure functions? 진정한 2016년 힙스터라면 이걸 써야지 친구. 들어는 봤나? 함수형 프로그래밍? 고차함수? 커링? 퓨어 뻥션? I have no idea what you just said. 니가 뭔소릴 하는지 1도 모르겠다. No one does at the beginning. Look, you just need to know that functional programming is better than OOP and that’s what we should be using in 2016. 첨부터 다 알 필욘 없지. 자, 2016년은 역시 함수형 프로그래밍의 해니까 OOP는 집어치우자. Wait, I learned OOP in college, I thought that was good? 저기요, 나 대학에서 OOP만 배웠고 그거 괜찮았는데? So was Java before being bought by Oracle. I mean, OOP was good back in the days, and it still has its uses today, but now everyone is realising modifying states is equivalent to kicking babies, so now everyone is moving to immutable objects and functional programming. Haskell guys had been calling it for years, -and don’t get me started with the Elm guys- but luckily in the web now we have libraries like Ramda that allow us to use functional programming in plain JavaScript. 자바도 오라클에 팔려버리기 전까지는 그랬었지. 내가 진짜 말하고 싶었던 건 OOP가 옛날에 좋았고 요즘에도 쓰인다고 해봤자 ‘상태를 변경한다’는 게 아이를 발로 차는 것과 맞먹는 무시무시한 일이라는 걸 이제 다들 알게 됐다는 거야. 그러니까 다들 불변하는 오브젝트를 다루는 함수형 프로그래밍에 관심을 가지는거지. 솔직히 하스켈 진영에서 지난 몇 년 동안 노력해 온 결과라고 본다. 어, Elm은 언급하지도 말자. 아무튼 요샌 그냥 자바스크립트로도 함수형 프로그래밍을 할 수 있는 Ramda 같은 라이브러리가 있어서 다행이야. Are you just dropping names for the sake of it? What the hell is Ramnda? 너 걍 아무 이름이나 막 던지는 거 아냐? 아 진짜 Ramnda가 뭔데? &gt; Are you just dropping names for the sake of it? 의 보다 정확한 번역을 제안해주세요. No. Ramda. Like Lambda. You know, that David Chambers’ library? 아니. Ramda. Lambda 같은거. David Chamber 라이브러리 알지? David who? David 뭐시기? David Chambers. Cool guy. Plays a mean Coup game. One of the contributors for Ramda. You should also check Erik Meijer if you are serious about learning functional programming. David Chambers. 존잘러. Coup 게임을 즐기지. Ramda의 컨트리뷰터 중 한 명이야. 그리고 진지하게 함수형 프로그래밍을 공부할꺼라면 Erik Meijer 정도는 알아둬야지. And Erik Meijer is…? Erik Meijer는 누군데…? Functional programming guy as well. Awesome guy. He has a bunch of presentations where he trashes Agile while using this weird coloured shirt. You should also check some of the stuff from Tj, Jash Kenas, Sindre Sorhus, Paul Irish, Addy Osmani 그 사람은 함수형 프로그래밍 언어 그 자체라고 볼 수 있음. 장난 아님. 우스꽝스러운 색 들어간 셔츠 입고 애자일 깔아뭉게는 프리젠테이션이 대단하지. 그거 말고도 Tj, Jash Kenas, Sindre Sorhus, Paul Irish, Addy Osmani 등도 봐야할껄. Ok. I’m going to stop you there. All that is good and fine, but I think all that is just so complicated and unnecessary for just fetching data and displaying it. I’m pretty sure I don’t need to know these people or learn all those things to create a table with dynamic data. Let’s get back to React. How can I fetch the data from the server with React? 알았으니까 이제 그만하지? 다 좋은데, 그냥 데이터를 받아다가 보여주는데 왜 그렇게 복잡하고 불필요한 것들이 많은지 모르겠네. 동적 데이터로 테이블 정도 만드는 데 이제까지 말한 사람들이나 기술들을 꼭 알아야 할 필요가 없을것 같은데. React로 되돌아가서, 어떻게 해야 데이터를 서버에서 받아올 수 있지? Well, you actually don’t fetch the data with React, you just display the data with React. 뭐, 꼭 React로 데이터를 받아올 필요는 없어. 그냥 보여주는 데만 써도 되지. Oh, damn me. So what do you use to fetch the data? 어우씨, 그럼 데이터는 어떻게 받아오는데? You use Fetch to fetch the data from the server. Fetch를 써서 받아오면 되지롱. I’m sorry? You use Fetch to fetch the data? Whoever is naming those things needs a thesaurus. 뭐라고? Fetch를 써서 데이터를 fetch 해온다고? 이름 지은 놈은 사전 좀 들고 있어야 되는거 아니냐? I know right? Fetch it’s the name of the native implementation for performing XMLHttpRequests against a server. Fetch는 서버에 대해 XMLHttpRequests를 수행하는 네이티브 구현의 이름이 맞는데? Oh, so AJAX. 그거 AJAX잖아. AJAX is just the use of XMLHttpRequests. But sure. Fetch allows you to do AJAX based in promises, which then you can resolve to avoid the callback hell. 응 AJAX는 XMLHttpRequests를 사용하는 것 뿐이야. 근데, Fetch를 쓰면 promises에서도 AJAX를 구현할 수 있어. promise는 콜백 지옥에서 널 해방시켜 줄 거고. Callback hell? 콜백 지옥? Yeah. Every time you perform an asynchronous request against the server, you need to wait for its response, which then makes you to add a function within a function, which is called the callback pyramid from hell. 응. 비동기 요청을 서버에 보내고, 응답을 기다리고, 이런 걸 함수 안에 함수로 넣고… 이런 걸 콜백 지옥이라고 해. Oh, Ok. And this promise thing solves it? 오. 그렇군. 그러면 promise가 그걸 해결해주고? Indeed. By manipulating your callbacks through promises, you can write easier to understand code, mock and test them, as well as perform simultaneous requests at once and wait until all of them are loaded. 당연하지. promise 써서 콜백을 다루면 코드 이해하기도 쉽고 목킹이나 테스트하기도 좋아. 게다가 동시 요청을 한 번에 수행해서 다 로드될 때까지 기다릴 수도 있고. And that can be done with Fetch? Fetch가 그걸 다 해준다고? Yes, but only if your user uses an evergreen browser, otherwise you need to include a Fetch polyfill or use Request, Bluebird or Axios. 응. 근데 사용자가 에버그린 브라우저를 쓰지 않으면 Fetch polyfill을 넣어 주거나 Request나 Bluebird, Axios 같은 걸 써야할 수도 있어. &gt; 에버그린 브라우저: 크롬이나 파이어폭스처럼 항상 최신 버전을 유지하는 브라우저 How many libraries do I need to know for god’s sake? How many are of them? 도대체 얼마나 많은 라이브러리를 알아야 하는거야? 얼마나 많은거냐고? It’s JavaScript. There has to be thousands of libraries that all do the same thing. We know libraries, in fact, we have the best libraries. Our libraries are huuuge, and sometimes we include pictures of Guy Fieri in them. 자바스크립트잖아. 똑같은 일을 하는 라이브러리들이 수천 수만 개나 있다고. 우린 라이브러리들을 알고 있지. 사실, 최고의 라이브러리들을 가지고 있어. 라이브러리들 사이에 Guy Fieri 사진을 끼워둘 만큼 거대하지. &gt; 역주) Guy Fieri, an American restaurateur, author, game show host, and television personality. : [https://en.wikipedia.org/wiki/Guy_Fieri](https://en.wikipedia.org/wiki/Guy_Fieri &quot;https://en.wikipedia.org/wiki/Guy_Fieri&quot;) Did you just say Guy Fieri? Let’s get this over with. What these Bluebird, Request, Axios libraries do? 방금 Guy Fieri라고 했어? 일단 좀 넘어가자. Bluebird, Request, Axios 라이브러리들이 하는 일이 뭐야? They are libraries to perform XMLHttpRequests that return promises. XMLHttpRequest를 수행해서 promise를 반환하는 라이브러리들이야. Didn’t jQuery’s AJAX method start to return promises as well? jQuery의 AJAX 메소드도 promise를 반환하게 되었지 않나? We don’t use the “J” word in 2016 anymore. Just use Fetch, and polyfill it when it’s not in a browser or use Bluebird, Request or Axios instead. Then manage the promise with await within an async function and boom, you have proper control flow. 2016년에 제이쿼리는 더이상 쓰지 않아. Fetch를 쓰면서 지원하지 않는 브라우저에는 폴리필 하거나, Bluebird, Request, Axios 등을 쓰지. 그리고는 async 함수의 await와 promise를 관리하면, 짜잔! 제대로 된 제어흐름이 구현되는거야. It’s the third time you mention await but I have no idea what it is. 네가 ‘await’를 언급한게 벌써 세번째인데, 난 그게 뭔지 모르겠어. Await allows you to block an asynchronous call, allowing you to have better control on when the data is being fetch and overall increasing code readability. It’s awesome, you just need to make sure you add the stage-3 preset in Babel, or use syntax-async-functions and transform-async-to-generator plugin. Await는 async한 호출을 블락해서 데이터가 fetch될 때 통제를 잘 할 수 있게 해주고, 결과적으로 전체 코드의 가독성을 높여줘. 정말 멋지다구. 단지 바벨의 stage-3 프리셋을 추가하거나, syntax-async-functions랑 transform-async-to-generator 플러그인을 쓰면 돼. This is insane. 미쳤네 미쳤어 No, insane is the fact you need to precompile Typescript code and then transpile it with Babel to use await. 아냐. 미친 짓이란 건 await을 쓰려면 프리컴파일된 Typescript 코드를 작성한 다음에 그걸 Babel이 변환해주는 것 같은 일을 가리키지. Wat? It’s not included in Typescript? 뭐?! 그거 Typescript에 포함된 거 아니었어? It does in the next version, but as of version 1.7 it only targets ES6, so if you want to use await in the browser, first you need to compile your Typescript code targeting ES6 and then Babel that shit up to target ES5. 어. 다음 버전엔 들어갈 거야. 그치만 현재 1.7 버전은 ES6만. 그래서 await 쓰려면 니가 짠 Typescript 코드를 ES6으로 변환해야 하고 그러면 Babel이 그걸 ES5로 바꿔줄거야. At this point I don’t know what to say. 이제 니가 뭐라고 하는지 진짜 모르겠다. Look, it’s easy. Code everything in Typescript. All modules that use Fetch compile them to target ES6, transpile them with Babel on a stage-3 preset, and load them with SystemJS. If you don’t have Fetch, polyfill it, or use Bluebird, Request or Axios, and handle all your promises with await. 봐봐. 쉬워. 전부 Typescript로 코딩해. Fetch를 사용하는 모든 모듈은 ES6로 컴파일 되고, stage-3 프리셋으로 babel을 써서 트랜스 파일한 다음에, SystemJS로 몽땅 로드할꺼야. Fetch가 없다고? polyfill 하면 되지. 아니면 Bluebird, Request, Axios가 등장한다면 어떨까? 그리고 모든 promise 를 await 로 쉐킷쉐킷. We have very different definitions of easy. So, with that ritual I finally fetched the data and now I can display it with React right? ‘쉽다’는 말에 대해 너랑 나는 기준이 완전 다른 것 같아. 이런 무지막지한 과정을 거쳐서 데이터를 받아왔다치자. 이제 React로 그걸 보여주는 거지? 맞아? Is your application going to handle any state changes? 니가 만들려는 애플리케이션에서 상태(state)도 관리해야 해? Err, I don’t think so. I just need to display the data. 어… 아닐 거야. 난 그냥 데이터를 보여주기만 하면 돼. Oh, thank god. Otherwise I would had to explain you Flux, and implementations like Flummox, Alt, Fluxible. Although to be honest you should be using Redux. 아 다행이다. Flux를 설명해야 하나 고민하고 있었거든. Flux 구현체가 Flummox, Alt, Fluxible 같은 게 있긴 하지만 솔직히 그냥 Redux 쓰는 게 낫거든. I’m going to just fly over those names. Again, I just need to display data. 이름이 너무 많아서 내가 파묻힐 지도 모르겠다. 다시 말하지만 난 그냥 데이터를 보여주면 된다고. Oh, if you are just displaying the data you didn’t need React to begin with. You would had been fine with a templating engine. 아하! 그냥 데이터를 보여주기만 하는 거면 React 쓸 필요 없어. 템플릿 엔진으로도 충분해. Are you kidding me? Do you think this is funny? Is that how you treat your loved ones? 너 장난하냐? 아니면 재미 삼아 이러는거야? 이게 네가 사랑하는 것들을 대하는 방식이니? I was just explaining what you could use. 난 그냥 니가 하게 될 일을 설명한 것 뿐야. Stop. Just stop. 이제 그만하자. I mean, even if it’s just using templating engine, I would still use a Typescript + SystemJS + Babel combo if I were you. 내 말은, 그냥 템플릿 엔진을 쓰는 경우에 나라면 Typescript + SystemJS + Babel 콤보를 쓸거라고. I need to display data on a page, not perform Sub Zero’s original MK fatality.Just tell me what templating engine to use and I’ll take it from there. 난. 그냥. 데이터를. 페이지에. 보여주기만. 할 거라고. 모탈컴뱃에서 척추 뽑는 기술 같은 건 필요 없어. 템플릿 엔진 이름만 말해주면 그거 쓸 게. Sub Zero’s original MK fatality: https://www.youtube.com/watch?v=g2JNxeWO_wA 영상을 참고하세요. There’s a lot, which one you are familiar with? 굉장히 많지. 넌 뭘 써 봤는데? Ugh, can’t remember the name. It was a long time ago. 어… 생각이 잘 안 나. 너무 오래 전 일이라. jTemplates? jQote? PURE? jTemplates? jQote? PURE? Err, doesn’t ring a bell. Another one? 음.. 아닐 걸? 다른 건 없어? Transparency? JSRender? MarkupJS? KnockoutJS? That one had two-way binding. Transparency? JSRender? MarkupJS? KnockoutJS? 이건 양방향 바인딩도 돼. Another one? 또 다른 건? PlatesJS? jQuery-tmpl? Handlebars? Some people still use it. PlatesJS? jQuery-tmpl? Handlebars? 이런 거 쓰는 사람도 있더라고. Maybe. Are there similar to that last one? 글쎄.. 비슷한 다른 종류는 뭐가 있어? Mustache, underscore? I think now even lodash has one to be honest, but those are kind of 2014. Mustache, underscore? 지금 같으면 lodash를 쓰겠지만 2014년이었을 테니까. Err.. maybe it was newer. 그때는 신상이었던 것 같아. Jade? DustJS? Jade? DustJS? No. 아니. DotJS? EJS? DotJS? EJS? No. 그것도 아니야. Nunjucks? ECT? Nunjucks? ECT? No. 그것도 말고. Mah, no one likes Coffeescript syntax anyway. Jade? 헐.. 아무도 Coffeescript 문법을 좋아하진 않던데. Jade? No, you already said Jade. 아니. 그리고 너 Jade는 이미 말했었어. I meant Pug. I meant Jade. I mean, Jade is now Pug. 내 말은 Pug. 아니 Jade. 아니 그러니까… Jade는 지금 Pug가 됐거든. Sigh. No. Can’t remember. Which one would you use? 후… 아니야. 기억 안 나. 너라면 뭘 쓸 거야? Probably just ES6 native template strings. 아마 ES6 네이티브 템플릿 스트링만 쓸 것 같아. Let me guess. And that requires ES6. 내가 맞춰볼게. 그러려면 ES6가 필요하겠지? Correct. 맞아. Which, depending on what browser I’m using needs Babel. 그걸 아무 브라우저에나 쓰려면 Babel을 사용해야겠고. Correct. 응. Which, if I want to include without adding the entire core library, I need to load it as a module from npm. 그 모든 라이브러리를 일일이 추가하지 않으려면 npm으로 설치해야겠고. Correct. 그래. Which, requires Browserify, or Wepback, or most likely that other thing called SystemJS. 그러려면 Browserify나 Webpack 아니면 SystemJS가 필히 있어야할 거야. Correct. 그렇지. Which, unless it’s Webpack, ideally should be managed by a task runner. Webpack이 없다면 그것들은 태스크 러너들이 관리해야겠고. Correct. 맞았어. But, since I should be using functional programming and typed languages I first need to pre-compile Typescript or add this Flow thingy. 그치만 함수형 프로그래밍이나 타입형 언어를 사용하고 싶다면 프리-컴파일 Typescript나 Flow 같은 걸 끼얹어야겠지. Correct. 그렇지 그렇지. And then send that to Babel if I want to use await. 그러고나서 이것들을 Babel로 보내고. 내가 await을 사용한다면 말야. Correct. 정확해. So I can then use Fetch, promises, and control flow and all that magic. 그러면 Fetch나 promises, control flow 같은 온갖 마법을 부릴 수도 있겠고. Just don’t forget to polyfill Fetch if it’s not supported, Safari still can’t handle it. 지원하지 않을 경우에 대비해서 Fetch의 polyfill을 잊지 마. 사파리는 아직도 지원 안 해. You know what. I think we are done here. Actually, I think I’m done. I’m done with the web, I’m done with JavaScript altogether. 있잖아. 우리 여기까지만 하자. 나 질렸어. 웹에도 질렸고 자바스크립트 같은 것들 따위에도 죄다 질렸어. That’s fine, in a few years we all are going to be coding in Elm or WebAssembly. 그거 좋네. 실은 몇 년 내에 Elm이나 WebAssembly로 갈아타야 할 거거든. I’m just going to move back to the backend. I just can’t handle these many changes and versions and editions and compilers and transpilers. The JavaScript community is insane if it thinks anyone can keep up with this. 난 백엔드나 하련다. 너무 많이 바뀌어서 감당이 안 돼. 이런 걸 다 따라올 수 있다고 생각했다면 자바스크립트 커뮤니티는 미친 거야. I hear you. You should try the Python community then. 그래. 그럼 너 파이썬 커뮤니티에 가봐. Why? 왜? Ever heard of Python 3? 파이썬 3 소식 못 들었어? 글의 구성이 매우 재미있을 뿐 아니라 내가 어느정도 최신트렌드의 물결에 같이 흘러가고 있는가를 알 수 있었다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}]},{"title":"나홀로 해커톤 시즌1","slug":"my-mini-hackerton-on-nf","date":"2016-11-16T03:24:03.000Z","updated":"2016-11-16T03:56:32.000Z","comments":true,"path":"2016/11/16/my-mini-hackerton-on-nf/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/16/my-mini-hackerton-on-nf/","excerpt":"","text":"기간교토대학교 NF기간(2016.11.18 ~ 11.23) 미니 해커톤 소개대학교 축제를 맞이하여 평소에 하지 못했던 개인 프로젝트를 진행해보자! 마음가짐무작정 코드부터 작성하지말고, 기획을 제대로 하자. 아키텍쳐를 설계해보자. 1. Make it markdown 웹페이지화 개요 : Make it markdown을 웹페이지화 시켜서 쓰기 편하게 하자. 기능 url입력하는곳에 입력하면 자동적으로 html파싱해서 markdown파일을 만들어준다. 광고도..? 기술 Nodejs herokuapp 2. NodeJS로 비서 봇 만들기 개요 : Mac내장 notes앱이랑 연동해서 Slack 비서봇을 만들자. 기능 매일아침 Todolist 알려주기(다음날 / 이번주 / 이번달) 학교 홈페이지 お知らせ에 새로운 글이 추가되었는지 확인. 기술 Nodejs 3. Snake게임 AI 만들기(희망사항) 개요 : c++로만든 Snake게임 AI를 만들어보자. 기능 길찾기 알고리즘(장애물 포함일 경우) 장애물 추가 메뉴 추가 기술 c++ 전부다 실행하는게 무리일 수 있으나 make-it-markdown웹페이지화 / slack봇만들기는 꼭 해보고싶다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"},{"name":"나홀로 해커톤","slug":"나홀로-해커톤","permalink":"https://voidsatisfaction.github.io/tags/나홀로-해커톤/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"React Native with 최신 자바스크립트 문법","slug":"react-native-javascript-environment","date":"2016-11-15T07:48:25.000Z","updated":"2016-11-15T08:23:01.000Z","comments":true,"path":"2016/11/15/react-native-javascript-environment/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/15/react-native-javascript-environment/","excerpt":"","text":"참조 JavaScript Environment - React Native babeljs.io Flowtype.org Object Spread esnext 고찰사부가 쓰던 모든 최신문법이 여기 있었다. 또한 React Native는 iOS simulator에서는 JavaScriptCore(Safari의 자바스크립트 엔진)를 사용하고, Chrome debugging에서는 V8엔진으로 따로 사용한다는 것을 알게 되었다. 여담 및 재미있는 코드object.assign() - MDN 1234567891011121314151617function test() &#123; let a = &#123; b: &#123;c:4&#125; , d: &#123; e: &#123;f:1&#125;&#125; &#125; let g = Object.assign(&#123;&#125;,a) let h = JSON.parse(JSON.stringify(a)); console.log(g.d) // &#123; e: &#123; f: 1 &#125; &#125; g.d.e = 32 console.log('g.d.e set to 32.') // g.d.e set to 32. console.log(g) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125; console.log(a) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125; console.log(h) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: &#123; f: 1 &#125; &#125; &#125; h.d.e = 54 console.log('h.d.e set to 54.') // h.d.e set to 54. console.log(g) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125; console.log(a) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125; console.log(h) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 54 &#125; &#125;&#125;test();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"JavaScript Spread Operator","slug":"javascript-spread-operator-study","date":"2016-11-15T05:21:56.000Z","updated":"2016-11-15T06:31:36.000Z","comments":true,"path":"2016/11/15/javascript-spread-operator-study/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/15/javascript-spread-operator-study/","excerpt":"","text":"참조 전개 연산자 - MDN Iteration protocols - MDN 용도Point 함수 호출 용 / 배열 리터럴 용 / 비구조화용 더 나은 apply 더 강력한 배열 리터럴 구문12345678// 함수 호출 용myFunction(...iterableObj);// 배열 리터럴 용[...iterableObj, 4, 5, 6];// 비구조화(destructuring) 용[a, b, ...iterableObj] = [1, 2, 3, 4, 5]; 더 나은 apply12345678910111213141516function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2];myFunction.apply(null, args);// 이는 다음과 같다.function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2];myFunction(...args);// 이런 식의 사용도 가능하다.function myFunction(v, w, x, y, z) &#123; &#125;var args = [0, 1];myFunction(-1, ...args, 2, ...[3]); 더 강력한 배열 리터럴1234var parts = ['shoulders', 'knees'];var lyrics = ['head', ...parts, 'and', 'toes']; // [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"] new에 적용123var dateFields = readDateFields(database);var d = new Date(...dateFields); 더 나은 push12345678910var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];// arr1에 arr2의 모든 항목을 덧붙임Array.prototype.push.apply(arr1, arr2);// 이는 다음과 같이 치환될 수 있음.var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2); iterable에만 적용12345678var obj = &#123;\"key1\":\"value1\"&#125;;function myFunction(x) &#123; console.log(x); // undefined&#125;myFunction(...obj);var args = [...obj];console.log(args, args.length) //[] 0","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"}]},{"title":"너무 헷갈리는 자바스크립트 Class개념","slug":"so-hard-javascript-class","date":"2016-10-21T01:11:37.000Z","updated":"2016-10-21T03:10:36.000Z","comments":true,"path":"2016/10/21/so-hard-javascript-class/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/21/so-hard-javascript-class/","excerpt":"","text":"자료 출처 자바스크립트 클래스를 정의하는 3가지 방법 자바스크립트 객체 생성 JavaScript 재입문하기 - MDN JavaScript Classes - MDN What is the ‘new’ keyword in JavaScript? - StackOverflow Constructors Considered Mildly Confusing 배경리액트 네이티브를 쓰다가 보면, 자바스크립트 코어를 알아야 문제를 해결해야 하는 경우가 종종 발생한다. 그리고 꼭 리액트 네이티브에서 뿐 아니라 자주 사용하는 언어의 코어를 공부하는 것은 필수적이라고 할 수 있다. 애초에 내가 객체지향 프로그래밍에 대한 이해가 달려서 그런지 내용 자체가 지금은 아리송한 경우가 많은데, 객체 지향 프로그래밍을 따로 공부해야 겠다. 너무 어렵다 멘붕하겠다. 그림으로 그려보자 핵심 자바스크립트에는 클래스가 존재하지 않는다. 클래스를 흉내낼 뿐이다. 의문 함수에서 객체를 생성하기 위한 new 라는 친구도 함수인가?","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"객체지향","slug":"객체지향","permalink":"https://voidsatisfaction.github.io/tags/객체지향/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}]},{"title":"자바스크립트 공부에 도움이 되는 사이트","slug":"good-site-for-javascript-study","date":"2016-10-14T06:56:24.000Z","updated":"2016-10-14T07:11:52.000Z","comments":true,"path":"2016/10/14/good-site-for-javascript-study/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/14/good-site-for-javascript-study/","excerpt":"","text":"JavaScript 입문 Codecademy - Learn JavaScript 아에 자바스크립트를 처음 접한다면 이곳의 튜토리얼을 하는 것을 추천한다. 언어는 영어지만 수준이 높은 영어가 아니라서 알기 쉽다. JavaScript Core Mozilla - JavaScript JavaScript 재입문하기 객체지향 JavaScript 소개 JavaScript classes 한글화가 되어있어서 정말 도움이 많이 되는 사이트 들이다. JavaScript 재입문하기는 내가 막연히 써오던 자바스크립트의 면면을 알기 쉽게 낱낱히 긁어주는 느낌이랄까. 정말 큰 도움이 되었다.","categories":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍/"}],"keywords":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}]},{"title":"React Native의 원리 및 JavaScript의 함수","slug":"javascript-study-and-react-native-function-method","date":"2016-10-14T02:26:21.000Z","updated":"2016-10-14T03:13:25.000Z","comments":true,"path":"2016/10/14/javascript-study-and-react-native-function-method/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/14/javascript-study-and-react-native-function-method/","excerpt":"","text":"출처 및 들어가 보면 좋은 사이트 사부의 말 Intoriduction to JavaScript - Mozilla 재단 객체지향 자바스크립트의 소개 - Mozilla 재단 의문내가 React Native코드를 작성하는 과정에서 다음과 같은 일이 있었다. ListView의 renderRow함수를 this.renderRow로 하고그 안의 TouchableOpacity의 onPress속성에 부모 컴포넌트에서 받아온 함수를 넘겨주려고 했는데,막상 클릭해보니 this.props.함수 == undefined 이라는 것이었다. 즉, this.props에는 그 함수가 존재하지 않는다는 것이었는데, 나는 renderRow라는 함수를 component class안에 정의해두었기 때문에당연히 this가 그 component를 가리킨다고 생각했다. 12345678910111213141516171819202122232425262728293031323334353637383940export default class SchoolBoardList extends Component &#123; static propTypes = &#123; boardItems: PropTypes.array.isRequired, boardItemOnpress: PropTypes.func.isRequired, &#125; constructor(props) &#123; super(props); const ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); this.state = &#123; dataSource: ds.cloneWithRows(this.props.boardItems), &#125;; this.renderRow = this.renderRow.bind(this); &#125; renderRow(rowData) &#123; const &#123; title, date, content, author, good, chat &#125; = rowData; return ( &lt;TouchableOpacity style=&#123;style.item&#125; onPress=&#123;() =&gt; &#123; this.props.boardItemOnpress(); &#125;&#125; &gt; ... &lt;/TouchableOpacity&gt; ); &#125; render() &#123; const &#123; dataSource &#125; = this.state; return ( &lt;View style=&#123;style.container&#125;&gt; &lt;ListView dataSource=&#123;dataSource&#125; renderRow=&#123;this.renderRow&#125; automaticallyAdjustContentInsets=&#123;false&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 이런식으로 되어있는 코드였다. 그래서 어? 어쩐일이지? 하면서 TouchableOpacity내부의 onPress속성 안에 console.log(this)를 넣어보니 웬걸 this는 전역객체를 의미하고 있었다! 그래서 나는 “뭐지? 난 클래스 안에다가 함수를 정의했는데? 왜 this가 전역객체인거야!” 하고 대혼란에 빠졌다. 사부의 답변그래서 나는 바로 사부에게 물어보았다. “왜 클래스 안에다가 함수를 정의했는데 this가 전역이 되는가?” 라고. 그래서 사부는 나에게 “React Native에서 render를 누가 부를까요? 라고 되물었다.” 답은 ‘React Native 엔진’이었다. 사부에 의하면 React Native엔진의 행동은 다음과 같다.(다소 차이점이 있다고는 하지만 지금은 이렇게 알아둬도 된다고 했다.) RN 엔진의 행동 index.js 실행 React Native Lifecycle실행 index.js안의 new component를 만듬 component.render()를 실행해서 view를 만듬 동작 메소드와 함수 클래스.함수 로 실행시키면 클래스 안에 있는 함수를 실행시키는 거여서 메서드 로 처리해요. 근데 형은 보통 this.함수를 클래스 안에서 사용하잖아요 이 경우에는 React Native입장에서 this.함수의 결과가 함수잖아요 그래서 함수로 실행시켜요. 즉 React Native엔진이 component.render()를 실행할때는 this가 component가 되니까 즉 class 가 되니까 render()함수 내에서 사용한 this.함수명 = 메소드(component 클래스 안에서의 함수 ex: 위의 경우 renderRow()와 같은 함수) 이렇게 되는거고 근데 버튼을 클릭하는 행동 같은 경우에는 class안에서 this를 정의해버렸으니 그 this가 전역객체니까 그걸 다시 component로 바꾸기 위해서 constructor나 render안에서 bind(this)하는 것이었다. 즉 그냥 renderRow함수 내에서 &lt;TouchableOpacity onPress={this.props.boardItemOnpress} 이렇게만 하면 RN엔진이 component.renderRow이렇게 실행하지 않기때문에 renderRow안의 this는 전역 객체가 되어 버리고 전역 this에는 this.props.boardItemOnpress가 존재하지 않으니까 this.props.함수 == undefined 이렇게 되었던 것이었다. 그렇기 때문에 이 문제를 해결하기 위해서는 클래스 내부의 constructor함수에서 this.renderRow = this.renderRow.bind(this) 이렇게 this의 지정을 component class로 명확히 해줘야 한다. 이는 함수.bind(this)를 해주기 전까지는 어디에서 혹은 무엇이 그 함수를 부르는가가 중요하지만, 함수.bind(this)를 해주는 행위는 어디에서 그 함수를 호출하든 함수 내부의 this를 지정 해주는 것이다. 느낀 점어떠한 기술을 확실히 ‘내 것’으로 만들기 위해서는 그 기술의 core를 이해하지 않으면 안된다. 이번 일을 계기로 JavaScript의 class개념, 함수 / 메소드 개념 React Native의 Lifecycle같은 개념을 알아야 하는 것의 중요함을 깨닫게 되었다. 자바스크립트에 대해서 깊이 이해하고 싶은 분들은 앞에서 소개한 mozilla재단의 javascript관련 문서를 읽는 것을 추천합니다. 역시 프로그래밍은 재미있다! 그리고 사부는 최고다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"Project Euler 134","slug":"project-euler-134-solution","date":"2016-10-06T16:55:01.000Z","updated":"2016-10-06T17:03:07.000Z","comments":true,"path":"2016/10/07/project-euler-134-solution/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/07/project-euler-134-solution/","excerpt":"","text":"ProblemPrime pair connection Consider the consecutive primes p1 = 19 and p2 = 23. It can be verified that 1219 is the smallest number such that the last digits are formed by p1 whilst also being divisible by p2. In fact, with the exception of p1 = 3 and p2 = 5, for every pair of consecutive primes, p2 &gt; p1, there exist values of n for which the last digits are formed by p1 and n is divisible by p2. Let S be the smallest of these values of n. Find ∑ S for every pair of consecutive primes with 5 ≤ p1 ≤ 1000000. Analysis12345678910111213141516가장 먼저 1부터 10^6+3 까지의 모든 소수의 배열을 구합니다.(10^6까지인 이유는 그래야지 p1이 10^6이하인 모든 소수를 포함할 수 있기 때문입니다.)그 배열에서 p1, p2를 선택해나가며 최소인 n 즉 s를 계산해나갑니다.최소인 n을 계산할때는 p2 * n 의 마지막자리 몇자리수 = p1 이렇게 되어야하는데이는 p1의 1의자리수부터 10의 자리수 100의자리수 ... 이런식으로 거꾸로 구해주면 됩니다.예를들어, p1 = 999979, p2 = 999983라고 하면n 의 1의자리수 = 9 따라서, p2 * i 에서의 i의 1의자리수는 3*3 = 9이므로 3이 되어야합니다.n 의 10의자리수 = 7 따라서, p2 * i 에서의 i의 10의자리수는 3*9 = 27(7 mod 10)이므로 9가 되어야합니다.....위의 행위를 여러번 반복하면 결국 최소인 n을 구할 수 있게됩니다.(그것이 least_n함수)저는 재귀함수를 이용하였습니다.Took 2.37secs Solution123456789101112131415161718192021222324252627282930313233343536373839require 'prime'class Problem134 def self.find_ans primes = primes_until(10**6+3) i = 0; s = 0 while primes[i] &lt; 10**6 p1, p2 = primes[i], primes[i+1] s += least_n(0,p1,p2,0) i += 1 end s end def self.least_n(n,p1,p2,sum) return sum if sum % 10**(p1.to_s.length) === p1 sum_last = (sum / 10**n) % 10 p2_last = p2 % 10 p1_last = (p1 / 10**n) % 10 i = 0 until (p2_last * i + sum_last) % 10 === p1_last i += 1 end sum += p2 * i * 10**n n += 1 least_n(n,p1,p2,sum) end def self.primes_until(n) primes = [] 5.upto(n)&#123; |i| primes.push(i) if i.prime? &#125; primes endendstart = Time.nowp Problem134.find_ansp Time.now - start EfficiencyO(nlogn) Afterthoughts거꾸로 풀어 올라간다는 발상만 할 수 있다면 그렇게 어려운 문제는 아니었던것 같다. 그런데 생각보다 거꾸로 올라가는 알고리즘을 구하는게 쉽지가 않아서 하루정도 쉬고 다시 그 부분만 알고리즘을 짰다. 이번에는 깊이 숙고해서 문제와 모든 정보를 공책에 쓴 뒤에 약간의 손코딩 후에 코드를 작성했는데 정말 큰 도움이 되었다. 역시 파인만 선생님.","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"MECE하게 '생각'하라.","slug":"lesson-from-teacher-with-errors","date":"2016-10-05T16:15:38.000Z","updated":"2016-10-06T04:58:42.000Z","comments":true,"path":"2016/10/06/lesson-from-teacher-with-errors/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/06/lesson-from-teacher-with-errors/","excerpt":"","text":"오늘 사부와의 미팅에서 배운 것들. 에러가 뜨면 막무가내로 실행하지 말고, 한 번 더 논리적으로 천천히 생각해보자. 본질에 입각해서 생각하자. 어떠한 process중에서 에러가 발생하면 그 process의 하나하나의 단계를 MECE(Mutually Exclusive and Collectively Exhaustive)하게 테스트한다. 편한 Tool을 항상 알아보자. ex) Reactotron, Vscode(plug in), Atom eslint, Atom terminal, Zsh 생산성을 상승 시키자. 기회가 있으면 꼭 참여해보자. 오랜만에 사부와 미팅을 했다. 방학동안에 한 번도 보지 못했는데, 여전히 사부는 사부였고, 나 역시 배운 것이 참 많았다. 위에 내가 배운것을 정리해 놓았다. 사고 정지의 위험성파인만 알고리즘, Do not study programming과 같은 글들을 보면 프로그래밍을 잘 하는 방법은 참 간단하고 명쾌하다. ‘손부터 움직이지 말고, 문제를 올바르게 파악하여 해결책에 대하여 숙고한 뒤에 해결하기 위한 코딩을 한다.’ 라는 것이다. 이미 위와같은 글을 몇번이나 읽고 ‘아 프로그래밍을 할 떄는 반드시 이러한 마음가짐으로 해야지’라고 다짐까지 했건만, 정작 내 앞에 ‘익숙하지 않은’문제들이 다가오면 불쑥 손부터 움직이기 시작한다. 아마 초보 코더의 본능과 같은 것일까? 이번 웹뷰 에러를 디버그 하는 상황에서도 아무런 논리적 근거도 없이 나는 ‘이걸 이렇게 변경하면 되겠지’라는 마음가짐으로 일단 iphone의 simulator를 실행시키려고 했다. 그 때 사부가 잠깐만요! 좀더 천천히 생각해봐요 하는 말에 ‘아 그렇구나 너무 조급했구나’ 싶었다. 그리고 논리적으로 따져나가니 결국에는 거짓말같이 전혀 단서가 없어보이는 문제가 해결되었다. 이렇게 문제가 해결되는 것을 보며 나는 몇해전 학교 세미나에서 교수님이 하신 말씀이 생각났다. 사고 정지야 말로 가장 위험한 것이다. 아무런 생각없이, 아무런 논리적 근거없이 일을 행하는 것은 위험하다는 말씀이었다. 이 말씀을 생각하니 또 세미나에서 교수님이 하신 다른 말씀이 생각났다. 아무리 복잡해보이는 일이라도 하나하나 MECE(빠짐없이, 중복없이)하게 행한다면 논리적인 문제는 반드시 특정할 수 있다. 어찌보면 당연한 말이고 나 역시 말을 들을때 마다 고개를 끄덕였던 기억이 있지만 이번에는 언제 그 말을 들었냐는 듯이 망각해버리고 말았다. 사실 이번 뿐 아니라, 다소 어려운 Euler Project문제를 풀 떄도 항상 잊어버리고 만다. 앞으로는 사고정지가 일어날 때 마다 MECE를 떠올려야겠다. 프로그래밍의 신비이번에 내가 사고정지에 대한 글을 쓰면서 생각난 프로그래밍의 재미있는 특징은, 프로그래밍에서 나오는 문제는 대부분 ‘끊임없이 생각하는 한 반드시 풀린다’는 점이다. 프로그래밍이 각종 작은 도구들을 조합해서 큰 물건을 만드는 것이기 때문에, 작은 도구들을 논리적으로 이리저리 조합하다 보면 반드시 해답이 나온다는 것이다. 하지만 해답을 찾는 과정을 위에 언급했듯이 문제를 올바르게 파악하여 해결책에 대하여 숙고한다면 더더욱 정확하고 빠르게, 그리고 간결하게 해답을 찾을 수 있을 것이다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Project Euler 131","slug":"project-euler-131","date":"2016-10-04T12:21:39.000Z","updated":"2016-10-04T12:32:42.000Z","comments":true,"path":"2016/10/04/project-euler-131/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/04/project-euler-131/","excerpt":"","text":"ProblemPrime cube partnership There are some prime values, p, for which there exists a positive integer, n, such that the expression n3 + n2p is a perfect cube. For example, when p = 19, 83 + 82×19 = 123. What is perhaps most surprising is that for each prime with this property the value of n is unique, and there are only four such primes below one-hundred. How many primes below one million have this remarkable property? Analysis let n^3 + n^2p = (n+k)^3 make it simple, n^2p = 3kn^2 + 3k^2n + k**3 if n &lt;= k, as n, p, k is all integers, k = nl n^2p = 3ln^3 + 3l^2n^3 + l^3n^3 p = nl(3 + 3l + l^2) as p is a prime n and l should be a 1 n = k = 1 p = 7 if n &gt; k, n = kl k^2l^2p = 3k(kl)^2 + 3k^2(kl) + k^3 l^2p = 3kl^2 + 3kl + k Therefore, p = 3k + 3k/l + k/l^2 as p is a prime, k = al^2, p = 3al^2 + 3al + a = a(3l^2 + 3l + 1) so, a = 1 p = 3l^2 + 3l + 1 Based on this fact, we can find all primes satisfing 3l^2 +3l + 1 under one million including p = 7 Took 0.004sec Solution12345678910111213141516171819require 'prime'class Problem131 def self.find_ans i = 1; cache = [] loop do value = 3*i**2 + i*3 + 1 break if value &gt; 10**6 cache.push(value) if value.prime? i += 1 end cache.length endendstart = Time.nowp Problem131.find_ansp Time.now - start EfficiencyO(n) AfterthoughtsOther solution. from umu What a beautiful nice little problem. Same as most of you, I guess. If n=ap, then n³+n²p=(a³+a²)p³, then a³+a² must be a cube, what is impossible, as next cube after a³ is a³+3a²+3a+1. So n and p are coprime, so are n² and n+p. So if n³+n²p=n²(n+p) is a cube, so n² and n+p are cubes, so n and n+p are cubes. (n+a)³-n³=3a+3a²+a³ is never prime for a&gt;1. So n and n+p are consecutive cubes. So it’s enough to check all differences between consecutive cubes for being prime. 정수론은 어렵지만 다가기는 생각보다 쉽고 흥미롭다.","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"Project Euler 123","slug":"project-euler-123","date":"2016-09-30T03:54:33.000Z","updated":"2016-09-30T04:15:12.000Z","comments":true,"path":"2016/09/30/project-euler-123/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/30/project-euler-123/","excerpt":"","text":"ProblemPrime square remaindersProblem 123 Let pn be the nth prime: 2, 3, 5, 7, 11, …, and let r be the remainder when (pn−1)n + (pn+1)n is divided by pn2. For example, when n = 3, p3 = 5, and 43 + 63 = 280 ≡ 5 mod 25. The least value of n for which the remainder first exceeds 109 is 7037. Find the least value of n for which the remainder first exceeds 1010. Analysisn is the n term of prime. if so,remainder = (Pn-1)^n + (Pn+1)^n === nPn({1+[-1]^(n-1)} + {1 + [-1]^(n)}) (mod Pn^2) In this situation, n should be odd since the remainder is 2 if n is even. Therefore, remainder is 2nPn (n is odd) Based on this fact, we can get first nth prime that exceeds 10^10 by using bruteforce. Efficiency O(n^(3/2))Took 1.8sec Solution1234567891011121314151617181920212223242526class Problem123 def self.find_ans limit = 10**10 ; i = 3 ; n = 1 loop do if prime?(i) if n % 2 === 1 n += 1 else n += 1 value = 2*n*i return n if value &gt; limit end end i += 2 end end def self.prime?(n) 2.upto(Math.sqrt(n))&#123; |i| return false if n % i === 0 &#125; return true endendstart = Time.nowp Problem123.find_ansp Time.now - start EfficiencyO(n^(3/2)) Afterthoughtshk’s solution on forum was quite interesting. he used the fact that the number of primes less than n tends to n/ln(n) then, n can be substituted by n/ln(n).thus, remainder could be substituted by 2*Pn^2/ln(n) Of course, according to Prime number theorem - Wikipedia, pi(n) is almost equal to(~) n/ln(n). the asymptotic notation meaning, again, that the relative error of this approximation approaches 0 as n increases without bound.","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"Project Euler 124","slug":"projecteuler124","date":"2016-09-29T14:40:35.000Z","updated":"2016-09-29T14:57:42.000Z","comments":true,"path":"2016/09/29/projecteuler124/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/29/projecteuler124/","excerpt":"","text":"ProblemOrdered radicalsProblem 124 problem is here Solution bruteforce dictionary You can define rad function by using prime_division method. And from 1 to 100000, you can get each of rad value. If a number’s rad is not included in cache, create new array of the rad value set.If it is included, just add on the rad value set After that, you can easily get E(10000) 1234567891011121314151617181920212223require 'prime'class Problem124 def self.find_ans cache = &#123;&#125; 1.upto(10**5) do |i| rad = rad(i).to_s cache.has_key?(rad) ? cache[rad].push(i) : cache[rad] = [i] end cache.values.flatten[9999] end def self.rad(n) value = 1 Prime.prime_division(n).each&#123; |e| value *= e.first &#125; value endendstart = Time.nowp Problem124.find_ansp Time.now - start EfficiencyO(n^(3/2))","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"파인만 알고리즘","slug":"feynman-algoritm","date":"2016-09-29T04:48:51.000Z","updated":"2016-09-29T05:29:04.000Z","comments":true,"path":"2016/09/29/feynman-algoritm/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/29/feynman-algoritm/","excerpt":"","text":"출처[과학의 창]내부와 외부, 그리고 경계 - 조선일보 파인만 알고리즘(알고리즘 문제풀이) 해결하려는 문제를 종이에 쓴다.(문제의 이해) 정말 골똘히 그 해결책을 생각한다.(알고리즘의 설계) 답을 쓴다.(코딩) 내용###[과학의 창] 내부와 외부, 그리고 경계 김범준 성균관대 물리학과 교수 | 2016/09/28 03:05 물리학자 파인만이 이용했다고 일컬어지는 일반적인 문제 해결 알고리듬이 있다. 숙지하면 이 방법으로 풀지 못할 문제가 없다. 독자들도 귀를 열고 주의 깊게 들어보시길. 파인만 알고리듬은 다음의 세 단계로 이루어진다. 첫째, 해결하려는 문제를 종이에 쓴다. 둘째, 정말 골똘히 그 해결책을 생각한다. 셋째, 답을 쓴다. 정말 쉽지 않은가. 처음 내가 이 이야기를 들었을 때는 그냥 농담인 줄 알았다. ‘파인만씨, 농담도 잘하시네!’라는 책 제목에서도 알 수 있듯 파인만은 물리뿐 아니라 농담도 정말 잘했던 사람이다.(참고로 물리학자들은 “물리학을 연구한다”고 하지 않고, 보통 “물리를 한다”고 말한다. 파인만은 물리 하는 사람이면 누구나 다 인정하는, 정말 물리를 잘했던 사람이다.) 나도 물리를 하며 살아온 세월이 좀 늘다 보니, 파인만 알고리듬에 대해 더 이해할 수 있게 되었다. 많은 독자가 이 해결 알고리듬의 가장 중요한 단계가 문제의 해결책을 고민하는 둘째 단계라고 짐작하겠지만, 그렇지 않다. 사실 가장 중요한 것은 문제를 종이에 쓰는 첫 단계다. 왜 그럴까. 문제를 풀 때, 가장 중요한 단계는 바로 문제가 뭔지를 아는 거다. 문제가 무엇인지를 알 때에만 문제를 종이에 적을 수 있다. 혹은, 문제를 종이 위에 적으려 노력하는 단계를 거쳐야만 문제가 명확해지기도 한다. 스스로 종이에 적지 못할 문제는 결코 해결할 수도 없다. 물리학자가 연구할 때도 마찬가지여서, 가장 중요한 단계가 바로 문제가 뭔지를 아는 거다. 문제가 무엇인지 파악할 때, 물리학자가 처음 거쳐야 하는 사고의 첫 관문이 있다. 오늘 할 얘기가 바로 이 부분이다. 물리학자는 문제를 종이에 적는 파인만 알고리듬 첫 단계의 맨 앞에서 먼저 ‘경계’를 설정한다. 안과 밖의 경계다. 무슨 얘길까. 공기 중에서 떨어지는 돌멩이의 운동을 이해하고자 하는 물리학자가 있다. 이 학자가 처음 하는 일은 이 물체의 운동을 이해하기 위한 사고의 체계 안에 도대체 무엇 무엇을 집어넣을까 하는 고민이다. 딱 돌멩이 하나만을 문제의 내부에 넣고, 돌멩이를 제외한 우주의 모든 것을 외부로 해서 둘 사이의 경계를 설정한다면 어떨까. 이 경우 돌멩이를 아래로 당기는 것이 내부에 없으니 돌멩이는 떨어질 수가 없고, 따라서 문제를 이렇게 적었다면 잘못 적은 거다. 당연히 문제의 내부에 다른 것을 더 넣어야 한다. 바로 돌멩이를 아래로 잡아끄는 지구의 중력이다. 자, 이제 돌멩이와 지구의 중력만을 문제의 내부(이 내부를 물리학자는 계(系), 혹은 시스템이라 부른다)로 생각해 이 둘과 우주의 나머지 모든 것 사이에 안과 밖의 경계를 설정하면 어떨까. 이 경우 돌멩이는 아래로 떨어지지만, 공기는 여전히 경계의 밖에 있으니 돌멩이는 공기에 의한 저항력을 느끼지 못한다. 공기의 효과까지 넣으려면 이제 경계는 조금 더 확장된다. 문제가 복잡할수록, 문제를 정확히 기술하기 위해 노력할수록, 내부와 외부를 나누는 경계는 시스템의 밖을 향해 확장된다. 확장된 경계로 둘러싸인 큰 시스템에서 문제의 해결은 점점 더 어려워지지만, 어려운 것이 두려워 우주 전체에서 너무 작게 시스템을 도려낸다면 말도 안 되는 엉뚱한 결과를 얻게 된다. 마치 아래로 떨어지지 않는 돌멩이처럼. 우리가 살아가는 사회에서 벌어지는 문제는, 아래로 떨어지는 돌멩이에 비하면 정말 복잡하다. 복잡한 현실의 문제를 이해하려면 내부와 외부 사이의 경계를 현명하게 설정하는 것이 필요하다. 경계가 분명하지 않을 때는 내부를 크게 설정하는 것이, 중요한 무엇을 외부로 배제해 잘못된 해결책을 찾는 것보다는 훨씬 더 바람직하다. 우리나라에서 벌어지는 일이라면 우리 모두는 내부라 할 수 있다. 우리 안에 외부는 없다. 다른 좋은 글Feynman Algorithm(파인만 알고리즘) - 잡생각 전문 블로그","categories":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}],"tags":[{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://voidsatisfaction.github.io/tags/알고리즘/"}],"keywords":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}]},{"title":"불교와 프로그래밍","slug":"buddhism-and-programming","date":"2016-09-29T02:08:18.000Z","updated":"2016-09-29T05:37:55.000Z","comments":true,"path":"2016/09/29/buddhism-and-programming/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/29/buddhism-and-programming/","excerpt":"","text":"법륜스님의 즉문즉설나는 요즈음 학교 도서관에 갈 때 팟캐스트 ‘법륜 스님의 즉문즉설’을 즐겨 듣는다. ‘법륜스님의 즉문즉설’은 법륜스님이 한국과 세계의 이곳저곳을 돌아다니시면서 강연하시는 내용이다. 여기서 특이한 점은, 스님이 일방적으로 자신의 생각과 견해를 전하는 것이 아니라는 점이다. 항상 스님은 질문자의 질문을 먼저 듣고 그것에 대한 답변을 하신다. 질문의 내용을 조금 발췌해보자면 다음과 같다. 부모님과의 사이가 좋지 않다. 어떻게 해야하는가? 아이가 공부를 안하는데 어떻게 하면 좋을까? 내가 화를 잘 참지 못한다. 어떻게 해야하는가? 시어머니와의 사이가 좋지 않은데 어떻게 해야하는가? 이 세상은 올바르게 사는 사람이 더 손해보는 것 같다. 나는 어떻게 살아야 하는가? 에피소드 하나 하나가 5~20분 사이로 생각보다 길지도 않고 정말 나도 한 번쯤은 생각해봤을 그런 문제들이며 현실과 동떨어지지 않은것 같아서 내용이 공감도 되고 참 재미있다. 하지만 즉문즉설의 백미는 역시 법륜스님의 명쾌한 대답이다. 즉문즉설을 관통하는 세가지 사고방식스님의 즉설을 듣고 있으면 언제나 세가지 원칙이 있다는 것을 느낀다. 모든 문제는 ‘나’에게 있다. 따라서 문제의 해결의 열쇠 역시 ‘나’에게 있다. 나는 나고 너는 너. 내 마음대로 타인을 변화시키려 하지마라. 기대하지 마라. 모든 문제는 ‘나’에게 있다.즉문즉설에서 질문자는 간혹 ‘~때문에 화가나거나 힘들다. 그렇다면 어떻게 그를 고쳐야 하는가?’ 와 같은 질문을 할 때가 있다. 그럴때 스님은 항상 모든 문제의 핵심은 바로 나 자신에게 있다고 말씀하신다. 그러므로 내가 어떠한 마음가짐을 가지느냐에 따라 문제를 해결할 수 있다고 하신다. 예를 들어, 남편이 매일 술을 마시고 들어와 화가났을 경우, 스님은 다음과 같이 조언하신다. ‘매일아침 하루 빠짐없이 매일 우리 남편 술을 꼭 먹고 들어오게 해주십시오’를 생각하며 108배를 하시죠. 그리고 오히려 술을 마시고 오지 않을 경우는 술을 준비해서 그 기도를 이루도록 해야합니다. 여기서 포인트는 마음에서 우러나와서 그렇게 해야 한다는 것이다. 그러면 3년 정도 후에는 남편의 술주정이 줄어들고 거짓말 같이 술을 마시지 않게 된다는 것이며, 자기자신의 생활이 술에 대한 스트레스가 사라짐과 동시에 보다 편해진다는 것이다. 나는 이 조언이 스님이 이야기하고자 하는 삶의 지혜를 고스란히 보여주고 있다고 생각한다. 그 지혜 중 하나는, 스트레스의 원인을 자기자신의 마음 으로 지목하신 것이다. 질문자는 남편이 술을 마시는 행위를 자기자신을 스트레스 받게하는 요소로 생각하고 있다. 하지만 스님은 술을 마시는 행위를 스트레스의 요소가 아닌, 긍정적인 요소 로 발상의 전환을 제안한다. 이것이 사고의 역전이자 즉문즉설의 백미. 나는 나고 너는 너. 내 마음대로 타인을 변화시키려 하지마라.또한 스님의 말씀에는 또 다른 지혜의 아름다움이 숨겨져 있는데 그것은 다름아닌 타인의 문제와 나와의 분리 다. 질문자는 분명 남편을 변화시킬 방법을 스님에게 묻고싶었겠지만, 스님은 ‘술을 마시는 일’자체를 내가 원하는대로 변화시키는 것은 욕심이라고 하신다. 사실 우리의 삶에서 타인의 행동을 긍정적인 방향이든 부정적인 방향이든 변화시키는 것은 정말 쉽지 않은 일이다. 내가 아무리 노력해도 그 사람은 내 노력을 티끌로도 보지 않는 경우도 심심치 않게 볼 수 있다. 따라서 만일 내가 타인을 변화시키는 것이 나의 과제이자 숙명으로 여기면 그 짐으로 인한 무게가 내 삶 자체를 짓누를 것이다. 그래서 스님은 애초에 타인의 짐을 자신이 짊어질 필요가 없다 고 역설하신 것이라고 생각한다. 이와 같은 마음가짐은 타인은 타인이 그러한 행동을 하는 자유가 있다는 것을 존중하는 동시에 나 자신의 짐도 덜어버리는 것이다. 기대하지 마라.마지막으로 스님은 ‘기대하지 말라’고 충고하신다. 대개 사람들은 기도를 하면서 자신을 둘러싼 환경이 변화가 되길 기대한다. 하지만, 기대를 하므로써 우리는 ‘기대’라는 이름의 새로운 짐을 짊어지게 되는 것이다. 만일 내 기대가 이루어지지 않는다면 그 기대라는 짐은 또다시 무거운 고뇌가 되어 나의 어깨를 누를것이다. 그래서 스님은 무주상보시(無住相布施). 즉, 어떠한 행위의 결과에서 아무런 기대를 하지 않는 마음의 중요성을 강조하신다. 중요한 것은 그 행위를 하는 것이지 행위의 결과는 자신의 마음과 아무 상관이 없다는 것이다. 프로그래밍과 불교법륜스님의 위의 세가지 원칙과 더 나아가 불교의 가르침은 프로그래밍의 세상과 일맥상통하는 부분이 있다. 다음과 같이 생각해보자. 가장 먼저, ‘나’는 나를 둘러싼 세상의 환경적 요소를 인수로서 받는 함수라고 생각한다. 그리고 그 함수 내부에는 내가 세상을 바라보는 시선 즉. 세상을 바라보는 알고리즘이 들어있는것이다. 이를 코드화한다면 다음과 같을 것이다. 1234567function me (나를 둘러싼 환경인수들)&#123; 내가 어떻게 환경을 바라보는가? 내가 어떻게 환경을 활용하는가?&#125;me(환경인수들) // 이것이 내가 세상에 살아가는 output. 내가 세상을 살아가는 모습 우리들은 보통 나를 둘러싼 환경인수들을 탓하며 무리하게 환경을 바꾸려고 한다. 하지만 법륜스님을 비롯한 불교의 가르침은 내가 제어할 수 없는 환경 인수에 초점을 맞추는 것이 아닌, 내가 어떻게 환경을 바라보는가? 내가 어떻게 나에게 주어진 환경을 활용하는가? 와 같은 ‘나’의 마음에 좋은 알고리즘을 만드려는 구상에 초점을 맞춘다. 사실 프로그래밍에서도 그렇듯이 함수의 output을 환경인수를 간단히 변경하는게 언뜻 보면 쉬울 것 같아보인다. 하지만 또 우리가 평소 생활하면서 느끼듯이 타인을 내가 원하는 방향으로 변화시키는 것은 쉽지 않다. 또한, 타인을 변화시켰을때는 반드시 부작용이 따른다. 하지만 그에 반하여, 잘 정의된 함수는 인수에 object가 오든, string이 오든 어떠한 자료구조, 어떠한 데이터 형태가 input으로 들어와도 원하는 output으로 변화시킬 수 있다. 따라서 우리는 어떠한 일이 내가 바라는 바 처럼 되길 바라고 기도하는 것이 아니라,어떠한 일이 닥치더라도 흔들리지 않는 그런 마음을 갖게 될 수 있도록 기도해야한다. 나는 어떠한 input이 오든 흔들리지 않고 나만의 신념을 지킬 수 있는 output을 낼 수 있는 그런 하나의 함수가 되고 싶다. 그래서 이제 나는 나에게 묻고자 한다. ‘나는 어떤 함수인가?’ ‘나의 함수는 환경인수를 제어하려 하는가, 아니면 내 마음의 좋은 알고리즘을 만드려하는가?’ 나는 종교를 믿지 않지만 어느종교이든 아름다운 말과 생각에는 그 특유의 향기가 있는 것을 느낀다. 마치, 절차지향적, 객체지향, 함수형, 선언형 프로그래밍 등등.. 각각의 프로그래밍 스타일이 고유의 매력을 뽑내는 것과 같이. 또한 각각의 프로그래밍 스타일도 궁극적으로 ‘좋은 프로그램을 작성한다.’ 라는 공통된 궁극적인 지향점 있듯이, 모든 종교도 ‘향기롭고 아름다운 삶을 산다’ 라는 공통의 궁극적인 지향점 있다고 생각한다. 이렇게 잘 생각해보면 세상을 살아가는 이치가 프로그래밍에도 곳곳에 스며들어있는 것이 아닌가 싶다. 작지만 나의 배움을 바탕으로 세상을 이런식으로 나만의 방식으로 의미부여를 해가는것은 참 재밌다. 같은 세상이라도 나에게는 조금 더 특별해 보이니까. 항상 좋은 말씀 감사합니다 법륜스님. 참고 법륜스님의 즉문즉설 팟캐스트","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍/"},{"name":"불교","slug":"불교","permalink":"https://voidsatisfaction.github.io/tags/불교/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"React Native 공부기 ~ Redux 후편","slug":"redux-study2","date":"2016-09-27T08:37:59.000Z","updated":"2016-09-27T10:25:38.000Z","comments":true,"path":"2016/09/27/redux-study2/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/27/redux-study2/","excerpt":"","text":"지난번에 공부한 것들 props의 공급원 dispatch(action.login(sessionID))의 의미 Redux의 매커니즘 다시 이야기로 돌아와서 저런식으로 redux에 state을 저장해서 다른 컴포넌트들이 그걸 참조하는거에요. Q) 그럼 dumbcomponent에서 데이터가변화 =&gt; screen으로 데이터가 감 =&gt; action생성 =&gt; dispather에 의한 redux상의 데이터변화(reducer) 요로코롬 이해하면 될까? 네. 아 이제 완벽히 이해된다. connect가 뭔지도 아시겟죠? 다른 일반적인 react-redux아키텍쳐랑 조금 달라서 아마 어려울수도 있었을거에요. dumbcomponent에서 데이터가변화 =&gt; screen으로 데이터가 감 =&gt; action생성 =&gt; dispather에 의한 redux상의 데이터변화(reducer) 이게 아니라, dumbcomponent에서 데이터가변화 =&gt; action생성 =&gt; dispather에 의한 redux상의 데이터변화(reducer) 이거여서. 보통은 react의 state을 아에 쓰지 않거든요. web front 의 경우에는 그냥 전부다 redux로 처리하니까 textInput 같은것도 redux state를 바꾸는걸로 해요. 근데 저희는 redux state을 핸드폰에다가 저장을 해놔서 그렇게 자잘한걸 전부다 redux로 처리를 하면 퍼포먼스가 나빠질 것 같아서, 적절히 나눈거구요. 대충 redux 에 대해 이해가 되셧나요? Q) redux로 처리하는것과 react자체 state로 처리하는 것의 차이는 뭐야? redux로 처리는 action, dispatch을 이용해서 redux의 state를 바꿔서 view을 바꾸는 거구요. react 자체 state는 this.setState을 통해서 view를 바꾸는 거죠. 그리고 사실 redux로 처리를 하면 action -&gt; middleware -&gt; reducer의 형태로 redux state가 변경되는데, 이 과정에서 여러가지를 할수가 있어요 반면에 setState는 setState 만으로 값을 바꾸는 거여서 복잡한 처리에는 좋지 않아요. 그렇지 middleware에서 데이터를 가공하든 다른곳에 통신을 하던 할 수 있으니까 redux는 Q) 근데 내 짧은 생각으로는 아무래도 redux가 여러가지 모듈을 거치니까 더 느릴거 같다는 생각이드는데.. redux가 더 느릴걸요. 더 느린데 할수있는게 많은거죠. 자유도 라고 해야하나요. 일단은 액션만 생성하면 redux의 정보를 변경할 수 있어요. this.props.lecture는 어디에서 오는가?아 그 props 가 어디서 오는지 설명해 드릴게요. 12345678910111213screen/LectureDetailScreenexport default connect( (state) =&gt; (&#123; timeTable: state.timeTable, &#125;), () =&gt; (&#123;&#125;), (stateProps, dispatchProps, ownProps) =&gt; (&#123; ...dispatchProps, ...ownProps, lecture: stateProps.timeTable[ownProps.day][ownProps.time], &#125;))(class LectureDetailScreen extends Component &#123; this.props.timeTable에 state.timeTable을 연결시켜요 또한, connect의 3번째 인수는 123456(stateProps, dispatchProps, ownProps) =&gt; (&#123; ...dispatchProps, ...ownProps, lecture: stateProps.timeTable[ownProps.day][ownProps.time], &#125;) 이런 함수인데 여기서 state.Props는 저기 위에 있는 { timeTable: state.timeTable }가 들어가 있어요. 그리고 ownProps는 원래 얘가 가지고 있는 props을 의미해요. lectureDetail은 timeTableScreen 에서 오는 얘인데 그때 Action.lectureDetail({ day, time})으로 보냈으니 this.props.day, this.props.time 을 받게 되죠 ownProps.day과 ownProps.time 은 timeTable에서 받은 day와 time 이에요 우리가 lectureDetail에서 필요한건 timeTable이 아니라 특정 timeTable안에 있는 특정 lecture 이기 때문에, lecture: stateProps.timeTable[ownProps.day][ownProps.time], 이걸 써서 this.props.lecture에 lecture을 주는거에요. 그래서 우리는 컴포넌트 안에서 this.props.lecture 만으로 얘의 lecture을 알수가 있죠. 사실 그냥 this.props.lecture = this.props.timeTable[this.props.day][this.props.time] 와 같이 해도 되는데 저건 별로 좋지도 않고 데이터 가공이랑 데이터 사용을 분리해서 적어놔야 보기가 편해요. “아 이 컴포넌트는 lecture을 쓰는구나 timeTable 전체를 안쓰는군.” 이렇게요. 123456789101112131415161718192021screen/scheduleScreenexport default connect((state) =&gt; &#123; const timetableScheduleItems = state.timeTable ? state.timeTable.reduce((sum, dayTimetable) =&gt; &#123; const dayTimetableSchedules = dayTimetable.reduce((daySum, lecture) =&gt; &#123; const timelines = lecture.timelines.map((timeline) =&gt; (&#123; ...timeline.info, lectureName: lecture.lectureDPName, &#125;)); return [...daySum, ...timelines]; &#125;, []); return [...sum, ...dayTimetableSchedules]; &#125;, []) : []; const scheduleItems = [ ...timetableScheduleItems, ...state.schedules, ]; return (&#123; scheduleItems, &#125;);&#125;)(class ScheduleScreen extends Component &#123; 이건 scheduleScreen 인데 얘도 timeTable을 가공해서 shceduleItem을 만드는거에요.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"https://voidsatisfaction.github.io/tags/Redux/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"React Native 공부기 ~ Redux 전편","slug":"redux-study1","date":"2016-09-27T05:17:03.000Z","updated":"2016-09-27T08:39:38.000Z","comments":true,"path":"2016/09/27/redux-study1/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/27/redux-study1/","excerpt":"","text":"나의 질문 123456_showAddLectureRatingScreen() &#123; const &#123; lecture &#125; = this.props; Actions.lectureRatingAdd(&#123; lecture, &#125;);&#125; 여기서 lecture를 this.props에서 가져오는데 그 props는 어디에서 오는지가 궁금해 사부의 답변props를 가져오는 곳이 3개가 있어요. 부모 Component가 주는 경우 Redux가 주는 경우 react-native-router-flux 라이브러리를 사용하는데 그때 화면전환을 할때 Action 을 이용하는데 그 화면전환을 할때 주는경우 그렇다면 const { lecture } = this.props; 이건 어디서 가져왔을까요? 그걸 알려면 일단 얘가 screen 컴포넌트인지 자식 컴포넌트인지를 봅니다. 왜냐면 자식컴포넌트는 무조건 부모 component에게만 props을 받고 redux나 router을 사용하지 않기로 했기 때문이죠 Component가 screen일 경우부모 component가 없기때문에 redux나 router 입니다근데 redux의 경우에는 12345678910LectureTimelineScreen과 reduxexport default connect( (state) =&gt; (&#123; user: state.userInfo, &#125;))(class LectureTimelineScreen extends Component &#123; ...&#125; 보통 screen은 일반 자식 컴포넌트와 다르게 connect라는 걸로 component을 감싸는데 저 connect가 redux와 연결하는 고리 같은거에요. 저렇게 하면 component에서 this.props.user가 생겨요.그리고 그 this.props.user는 현재 redux의 state의 userInfo가 들어가게 되는거죠그래서 맨위를 보면 redux에서 받는 props을 알수 있어요 userInfo는 Reducer에 있는 userInfo.js 얘가 되는거구요 1234567timeTableScreen과 reduxexport default connect((state) =&gt; (&#123; timeTable: state.timeTable, timeTableSetting: state.setting.timeTableSetting,&#125;))(class timeTableScreen extends Component &#123; timeTableScreen은 timeTable.js reducer와 setting.js reducer를 참조해서 가져오게 됩니다. 그렇다면 위에 redux에서 정의되지 않는 props는 router에 의해서 가져오는 props라고 생각할 수 있죠. 그렇다면 lectureDetail에서 가지고 있는 this.props.lecture는 12345678910timeTableScreen의 _clickLecture함수_clickLecture(time, day, lectureCode) &#123; Actions.lectureDetail(&#123; time, day, lectureCode, &#125;);&#125; timeTableScreen을 보면 저걸로 인해서 어디를 클릭했는지를 알수가 있어요. 월요일 1겐 이면 day: 0 time: 0이 this.props 에 들어가게 되겠죠. 저렇게 해서 화면끼리 데이터를 교환할수 있어요. 12345678910111213LectureDetail과 reduxexport default connect( (state) =&gt; (&#123; timeTable: state.timeTable, &#125;), () =&gt; (&#123;&#125;), (stateProps, dispatchProps, ownProps) =&gt; (&#123; ...dispatchProps, ...ownProps, lecture: stateProps.timeTable[ownProps.day][ownProps.time], &#125;))(class LectureDetailScreen extends Component &#123; 일단 맨끝만 보면 this.props.lecture에 stateProps.timeTable[ownProps.day][ownProps.time], 가 들어간다는걸 알수가 있어요 lecture는 저기에서 오는거에요 그리고 this.props.timeTable 에는 state.timeTable 이 들어가겟죠 여기까지는 이해가 되시나요? 더 깊이 나아가서Q) 흠 철아 근데 redux의 state는 schema같이 형태만 정해져있는거야 아니면 정보가 저장되어있는거야? 정보가 저장되어 있어요.형태만 있는게 처음 상태에요 그리고 우리가 dispatch(action.xxxxxx) 이런식으로 쓰는 코드가 있잖아요.그 action이 reducer 에 있는 안에 있는 코드를 불러내요.그러면 그에 알맞게 state가 바뀌게 되는거죠. 가장 쉬운걸로는 1234567891011121314151617181920212223 reducers/session.js export default function reducer(state = initialState, action = &#123;&#125;) &#123; switch (action.type) &#123; // focus action is dispatched when a new screen comes into focus case LOG_IN : return &#123; ...state, sessionID: action.sessionID, logged: true, &#125;; case LOG_OUT : return &#123; ...state, sessionID: '', logged: false, &#125;; default: return state; &#125;&#125; 이렇게 되어 있잖아요 LoginScreen 보면 로그인 성공하면 dispatch(action.login(sessionID)); 이런코드를 불러요 응응 저기 있는 login은 123456789101112131415161718192021action/session.jsexport const LOG_IN = 'LOG_IN';export const LOG_OUT = 'LOG_OUT';import &#123; setSession &#125; from '../api/base';/* * 액션 생산자 */function login(sessionID) &#123; setSession(sessionID); return &#123; type: LOG_IN, sessionID &#125;;&#125;function logout() &#123; setSession(''); return &#123; type: LOG_OUT &#125;;&#125;export default &#123; login, logout &#125;; 여기 있는데 흐음 일단 setSession은 예외이니 그거 말고 login하면 return이 return { type: LOG_IN, sessionID }; 이거죠 Q) dispatch(action.login(sessionID));이 코드에서 session.js를 참조하라고 어디에 나와있어? action이 import action from &#39;../../actions&#39; 이런 코드 위에 있죠 그러면 action/index.js 을 참조하겟죠? 우리 컴포넌트들도 그냥 폴더까지만 참조하게하면 자동으로 index.js 을 참조하니까요 그래서 action/index.js을 보면 얘가 session을 참조해요 … 이게 참조표신가 보네 참조보다는 import가 맞겠죠. 그러면 return { type: LOG_IN, sessionID }; 얘가 return 되고 그걸 dispatch가 reducer로 보내요. 그러면 또 reducer/index.js을 보고 지금 type: LOG_IN 이죠 type: LOG_IN 1234567891011121314151617181920212223reducer/session.js export default function reducer(state = initialState, action = &#123;&#125;) &#123; switch (action.type) &#123; // focus action is dispatched when a new screen comes into focus case LOG_IN : return &#123; ...state, sessionID: action.sessionID, logged: true, &#125;; case LOG_OUT : return &#123; ...state, sessionID: '', logged: false, &#125;; default: return state; &#125;&#125; 그러면 action.type이 LOG_IN이 코드가 실행이 되고 Q) 아 그럼 index.js안에 사실상 모든 reducer type가 들어가있는거나 마찬가진데 알기 쉽게 나눈거 뿐이구먼 저거 하나하나 import 하면 귀찮아 지니깐 바로 reducer 까지만 import 하도록 한거에요. action도 마찬가지고요. 123456return &#123; ...state, sessionID: action.sessionID, logged: true,&#125;; 여기서 return값이 새로운 state.session 값으로 바뀌어요 12345const initialState = &#123; sessionID: '', logged: false,&#125;; 이게 초기치. 그래서 sessionID가 생기고 logged가 true가 되죠. 마찬가지로 reducer/schedule.js 을 보면 12345678910111213141516171819202122reducer/schedule.jsswitch (action.type) &#123; // focus action is dispatched when a new screen comes into focus case ADD_SCHEDULE : return [...state, action.newScheduleItem]; case EDIT_SCHEDULE : return [ ...state.slice(0, action.index), action.scheduleItem, ...state.slice(action.index + 1), ]; case DELETE_SCHEDULE : return [ ...state.slice(0, action.index), ...state.slice(action.index + 1), ]; default: return state; &#125; 스케쥴 추가면 뒤에 새로운 아이템을 붙이고 edit면 그 아이템만 교체 delete면 그거만 제거 아하 알겠어. 매우매우 알기 쉬운 설명이구만! 아 드디어 리덕스의 매커니즘을 이해했어 ㅠㅠ. 데이터변경을 위한 흐름을 파악하면 되는거네. 이런식으로 되어있다보니 아무래도 전에 봤던 그림이 어려워보였던 것 같아. the upper picture is from http://www.slideshare.net/nikgraf/react-redux-introduction 이제는 이 그림도 이해할 수 있게 되었어! 리덕스의 매커니즘 dumbcomponent에서 데이터가변화 =&gt; screen으로 데이터가 감 =&gt; action생성 =&gt; dispather에 의한 redux상의 데이터변화(reducer) 2편에서 게속…","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"https://voidsatisfaction.github.io/tags/Redux/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"Project Euler 121","slug":"2016-9-27-a-ProjectEuler","date":"2016-09-26T16:38:09.000Z","updated":"2016-09-26T16:42:42.000Z","comments":true,"path":"2016/09/27/2016-9-27-a-ProjectEuler/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/27/2016-9-27-a-ProjectEuler/","excerpt":"","text":"ProblemDisc game prize fundProblem 121 A bag contains one red disc and one blue disc. In a game of chance a player takes a disc at random and its colour is noted. After each turn the disc is returned to the bag, an extra red disc is added, and another disc is taken at random. The player pays £1 to play and wins if they have taken more blue discs than red discs at the end of the game. If the game is played for four turns, the probability of a player winning is exactly 11/120, and so the maximum prize fund the banker should allocate for winning in this game would be £10 before they would expect to incur a loss. Note that any payout will be a whole number of pounds and also includes the original £1 paid to play the game, so in the example given the player actually wins £9. Find the maximum prize fund that should be allocated to a single game in which fifteen turns are played. Solution Get the all posibilities player lose(using combination) Then, get the winning rate of player for this game Get maximum prize 1234567891011121314151617181920class Problem121 def self.find_ans total_lose = 0 8.upto(15) do |lose| total_lose += (1..15).to_a.combination(lose).to_a.map&#123; |e| e.reduce(:*) &#125;.reduce(:+) end winning_rate = 1 - Rational(total_lose,factorial(16)) prize = (1/winning_rate).floor end def self.factorial(num) result = 1 num.downto(1) do |i| result *= i end result endendp Problem121.find_ans","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"기여도 1%의 의미","slug":"2016-9-23-a-1:100","date":"2016-09-23T11:52:00.000Z","updated":"2016-09-27T07:53:43.000Z","comments":true,"path":"2016/09/23/2016-9-23-a-1:100/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/23/2016-9-23-a-1:100/","excerpt":"","text":"드디어 나의 첫 pull request가 반영되었다! 총 코드변동량 : 약 80,000 나의 코드변동량 : 약 800 나의 기여도 : 1% 기여도 1%얼마전에 나는 정말 오랜만에 짜릿한 경험을 했다. 현재 나와 사부님이 같이 진행하는 프로젝트에서 까다로운 여러 테스트(퍼포먼스 리뷰, 코드 리뷰, Eslint)를 잘 극복해서 드디어! 프로젝트를 시작한지 어언 4개월만에 처음으로 Pull Request가 받아들여서 Master에 Merge되는 영광을 누렸다. 약 4개월 전 처음 React Native에 입문했을때 나에게는 너무나도 낯선것들 투성이였다. 가장 먼저, 나는 항상 Ruby만 써왔기 때문에 React Native의 모든것들이 다 낯설었다. state와 props flex 시스템 상속 flux / redux xcode simulator npm … (redux는 아직도 잘 모르겠다.) 앞서 나열한 모든 개념들이 내게는 낯설었고 도대체 어디서부터 어떻게 공부해야할지 몰랐다. 그리고 너무나도 모르는게 많아서 내가 사부와 같은 위치에서 기술에 대해서 토론하고 코드를 작성할 수 있을거라고는 상상도 못했었다. 그런데 그게 현실로 되었다. 사실 4개월동안 계속 React Native만 공부한 것은 아니었다. 도중에는 회의감이 들어서 당분간 React Native의 코드는 처다도 보지 않았던 때도, 대학원 시험공부에 쫓겨서 한달정도는 전혀 코드를 만지지 않았던 때도 있었다. 그래도 포기 않고 하나하나 사부가 하라는 것을 해나가니 첫 Pull Request까지 성공하게 되었다. 이제 겨우 첫 공헌이고 겨우 기여도 1%에 불과하다고 생각할 수도 있지만, 나에게는 매우 크나큰 의미를 가지고 있는 1%라고 생각한다. 마치 닐 암스트롱이 달에 첫 깃발을 꽂듯이, 콜럼버스가 신 대륙을 발견하듯이, 아리스토텔레스가 욕조속에서 유레카를 외치듯이.. 이 1%는 앞으로 내가 개발자 / 엔지니어 / 프로그래밍을 사랑하는 사람으로서 크나큰 1%가 되리라 확신한다. 왜냐하면 나는 내 1%를 정말 자랑스럽게 생각하기 때문이다. 이 글을 보는 다른 사람들과 미래의 나에게 지금 이 행복한 기분을 전달하고자 이 글을 쓴다. 나의 위대한 1%를 기리며","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"},{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Xcode버전업과 RN개발환경 오류들","slug":"2016-9-19-a-rnerrors","date":"2016-09-19T02:52:00.000Z","updated":"2016-09-26T15:47:35.000Z","comments":true,"path":"2016/09/19/2016-9-19-a-rnerrors/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/19/2016-9-19-a-rnerrors/","excerpt":"","text":"이 글을 쓰게 되는 계기는 다름이 아니라 몇가지 에러로 인하여 나와 사부가 정말 말 그대로 하루종일 고생했다는 점이다. 그래서 앞으로 이러한 에러가 나올 경우에 잘 대처할 수 있도록 머리에 담아두고자 이곳에 글을 쓴다. 발단 : Git사용의 미숙함 + Xcode업데이트Remote에서 git pull을 한 이후로 이상하게 simulator가 실행되지 않는 버그가 발생했다. 그리고, 나는 그것이 Xcode가 업데이트되지 않았기 때문에 발생한 문제라고 생각했다. 그래서 나는, 끔찍한 미래가 기다리는 것도 모른채 RN노드 모듈을 전부 삭제하고 다시 깔고, cache도 전부 지웠다 다시 깔았으며, xcode마저 업데이트 했다. 해결해결은 다음과 같은 순서로 행해졌다. 1. xcode업데이트에 의한 websocket오류 =&gt; RCTWebSocket의 Custom Compiler Flag의 value 제거 2. terminal상에서 무엇이 에러인지 모를때 =&gt; xcode에서 build후 error를 추출한다.3. xcode를 build할때 =&gt; 흰색으로 열어라4. linker library지원 (7.0버전 설정을 로컬에 맞는 9.1로 변환) 5. suitable library 오류 =&gt; 시뮬레이터를 ios10 에서 ios9로 실행을 바꿈(없으면 새로 다운받아야함)123456789dyld: Library not loaded: @rpath/libFirestack.a Referenced from: /Users/tech-camp-064/Library/Developer/CoreSimulator/Devices/3692613C-5EBB-4BAD-9496-C336B2629BC8/data/Containers/Bundle/Application/D73B751F-39B9-4230-818A-C7C5BF5B7C66/SchoolShare.app/SchoolShare Reason: no suitable image found. Did find: /Users/tech-camp-064/Library/Developer/Xcode/DerivedData/SchoolShare-dlacbtwbdazihdgkeyjricajfoer/Build/Products/Debug-iphonesimulator/libFirestack.a: required code signature missing for &apos;/Users/tech-camp-064/Library/Developer/Xcode/DerivedData/SchoolShare-dlacbtwbdazihdgkeyjricajfoer/Build/Products/Debug-iphonesimulator/libFirestack.a&apos;(lldb) 6. 무슨 이유인지 모르겠지만 npm install을 해도 존재하지 않다고 하면 그것은 수동으로 npm i 해줘야 한다 이와같은 방식으로 해결했다. 교훈 xcode업데이트는 팀원과 협의하에 행해야 한다. terminal상에서 error의 내용을 잘 확인할 수 없을때에는 xcode에서 build하면 단서를 얻을 수 있다. xcode를 틈틈이 공부할 수 있으면 참 좋을것 같다. 그래도 오늘도 굴복하지 말고 Happy Coding!","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"오늘 또 느낀 것들...","slug":"2016-9-09-a-gitandmygit","date":"2016-09-09T02:52:00.000Z","updated":"2016-09-26T15:57:24.000Z","comments":true,"path":"2016/09/09/2016-9-09-a-gitandmygit/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/09/2016-9-09-a-gitandmygit/","excerpt":"","text":"최근에 했던 것오늘은 그동안 내가 작업했던 일을 갈무리 짓는 날이었다. 솔직히 얘기하자면 하는 일이 그렇게 엄청 대단한 것은 아니고, React Native의 Component 들을 Atomic Design에 맞게 리팩토링 하는 일을 했다. 애초에 나 자신이 작성한 코드가 아니었기때문에 코드를 분석하는 것 부터가 일이었으며, 분석한 뒤에도 모르는 것 투성이었다. 그래도 일단은 Atomic Design에 관한 글과, 사부의 설명을 들으면서 하나하나 정리해 나가기 시작했다. 그랬더니 처음에는 엄청나게 막연하게 ‘너무 힘들 것 같다’라고 생각되었던 일들이 생각보다 ‘할만 하구나’라는 생각이 들었다. 내가 했던 일을 잠깐 설명해보자면 AddNewLecture이라는 하나의 Screen을 Organisms, Molecules, Atoms까지 분해하여서 Module화 시키는 것이었다. 그리고 이렇게 모듈화를 시키므로써, 어플리케이션의 구조를 중복을 제거함과 동시에 재활용가능하게 하는 것이었다. 또한, Proptypes를 이용하여 보다 엄밀하게 기능을 제어할 수 있도록 했다. 그리고 그 과정은 Screen을 복사 분해 합성 이렇게 처리하였다. 또 다시 높은 산이렇게 전부 코드를 처리하고 난 다음 나의 기분은 정말 뿌듯했다. ‘이제는 나도 일인분은 할 수 있겠구나’라고 생각했다. 그러나 처리한 일을 기존의 일과 병합하는 과정에서 큰 난관에 봉착했다. 원래 내가 작업하고있던 파일들은 local환경에서 새로운 branch를 만들어서 작업중이었다. 나는 그것을 한차례 수정이된 remote환경의 master의 내용을 내 local환경의 master branch에 적용한 뒤 다시 그 내용을 local의 새 브랜치에 merge하고 그 내용을 다시 remote에 push해서 pull request에 관한 내용을 작성 해야만했는데, 2에서 merge하는 과정에 내가 무엇인가를 잘못헀는지 엄청나게 많은 오류가 뜨면서 많은 파일들이 수정되어버렸다. 아차차 싶어서 사부에게 결과를 말한 뒤, 사부의 제안에 따라서 SourceTree라는 프로그램을 다운로드 받아서 다시 commit직후의 상태로 되돌릴 수 있었다. 그러나 npm install이후 npm test에서 eslint에 관한 수많은 error들 pull request를 작성한 것들에 대한 사부의 신랄한 코멘트 “앞으로는 그냥 commandline git대신 SourceTree로 하세요.” 를 보면서 약간 자존심에 금이갔다. 그래도 난 나름대로 잘 했다고 생각했는데, 나의 욕심으로 정상만을 바라보다 그만 눈 앞의 돌에 고꾸라 넘어져버렸다. 그래도 그냥, 천천히, 올라야지그래도 나는 산을 오르는것을 힘들어할 망정 포기하지는 않을 것이다. 내가 갖고 있는 나만의 장점 중 하나는, ‘위기를 기회로 바꾸는 마음가짐’에 있다고 생각한다. 내 앞에 크나큰 산들이 가로막고, 그 산들이 얼마나 더 많이 있는지 모르지만 나는 이 위기를 기회로 바꾸어서 내가 한결 나아갈 수 있도록 해야겠다. 이렇게 한 번 넘어졌을때야 말로 바로 내가 가장 나 다워질 수 있는 시기이자, 내게는 기회다. 그래 지금 산을 오르는 과정에서 한 번 넘어졌어도, 그래도 그냥, 천천히, 올라야지. 앞으로 해야 할 Task ESlint Error처리 + github feedback =&gt; npm test =&gt; remote push =&gt; merge Git / Github 이해될 때 까지 해보자. 한 번 누가 이기나 해보자. SourceTree npm test에 대하여","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Nodejs 공부기 4 ~ Session & Password & Socket.io","slug":"2016-9-03-b-securitysocketio","date":"2016-09-03T02:52:00.000Z","updated":"2016-09-26T15:46:18.000Z","comments":true,"path":"2016/09/03/2016-9-03-b-securitysocketio/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/03/2016-9-03-b-securitysocketio/","excerpt":"","text":"layout: post title: Nodejs 공부기4 ~ Session &amp; Password &amp; Socket.io포인트 Session Client에 저장하는 것은 sessionid뿐. 실질적인 데이터는 서버에. Password md5 + salt(global, respective) sha512 + salt PBKDF2 Socket.io 정의는아직 실시간 어플리케이션(채팅, 캐치마인드) Real codeSession123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const express = require('express')const session = require('express-session')const FileStore = require('session-file-store')(session)const bodyParser = require('body-parser')const pug = require('pug')const app = express()app.set('views', './views')app.set('view engine', 'pug')app.use(session(&#123; store: new FileStore(), secret: 'wefjwoefkwlefmwlkm', resave: false, saveUninitialized: true,&#125;))app.use(bodyParser.urlencoded(&#123; extended: false &#125;))// this scope!const userDB = &#123; findUser: function(id,password)&#123; if (!this.allUsers[id] || this.allUsers[id]['password'] != password) &#123; return false &#125; else &#123; return true &#125; &#125;, allUsers: &#123; admin: &#123; password: '123' &#125;, nersery: &#123; password: '123123' &#125;, lionking: &#123; password: '123' &#125; &#125;&#125;// req.session.countapp.get('/login', (req, res) =&gt; &#123; if (req.session.userInfo) &#123; res.redirect('/welcome') &#125; else &#123; errorMessage = req.session.err res.render('login',&#123;errorMessage: errorMessage&#125;) &#125;&#125;)app.post('/login', (req, res) =&gt; &#123; const userId = req.body.userId const userPassword = req.body.userPassword if (userDB.findUser(userId,userPassword)) &#123; delete req.session.err req.session.userInfo = &#123; id: userId &#125; res.redirect('/welcome') &#125; else &#123; req.session.err = 'Check your id or password' res.redirect('/login') &#125;&#125;)app.get('/logout', (req, res) =&gt; &#123; delete req.session.errorMessage delete req.session.userInfo res.redirect('/login')&#125;)app.get('/register', (req, res) =&gt; &#123; if (req.session.userInfo) &#123; res.redirect('/welcome') &#125; else if(req.session.errorMessage)&#123; res.render('register',&#123;errorMessage: req.session.errorMessage&#125;) &#125; else &#123; res.render('register') &#125;&#125;)app.post('/register', (req, res) =&gt; &#123; const userId = req.body.userId const userPassword = req.body.userPassword const userPasswordConfirm = req.body.userPasswordConfirm if (userDB.allUsers[userId]) &#123; req.session.errorMessage = 'the id is already exist' &#125; else if(userPassword.length &lt; 3)&#123; req.session.errorMessage = 'your password should be more than 3 characters' &#125; else if(userPassword !== userPasswordConfirm)&#123; req.session.errorMessage = 'Password is not correct with Password confirm' &#125; else &#123; delete req.session.errorMessage userDB.allUsers[userId] = &#123; password: userPassword&#125; req.session.userInfo = &#123;id: userId&#125; req.session.save(() =&gt; &#123; res.redirect('/welcome') &#125;) &#125; res.redirect('/register')&#125;)app.get('/welcome', (req, res) =&gt; &#123; const userId = req.session.userInfo.id res.render('welcome', &#123;userId: userId&#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log('Connected at 3000 port!')&#125;) Socket.iojs part123456789101112131415161718const app = require('express')()const http = require('http').Server(app)const io = require('socket.io')(http)app.get('/', (req, res) =&gt; &#123; res.sendFile(__dirname + '/views/index.html')&#125;)io.on('connection', (socket) =&gt; &#123; socket.on('chat message', (msg) =&gt; &#123; io.emit('chat message', msg) &#125;)&#125;)http.listen(3000, () =&gt; &#123; console.log('Connected at 3000 port!')&#125;) html part12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"messages\"&gt;&lt;/ul&gt; &lt;form&gt; &lt;input id=\"m\" type=\"text\" autocomplete=\"off\" /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; const socket = io() $('form').submit( () =&gt; &#123; socket.emit('chat message', $('#m').val()) $('#m').val('') return false &#125;) socket.on('chat message', (msg) =&gt; &#123; $('#messages').append($('&lt;li&gt;').text(msg)) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 참조 생활코딩 Password 보안 Socket.io Getting Started","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"Socket.io","slug":"Socket-io","permalink":"https://voidsatisfaction.github.io/tags/Socket-io/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}]},{"title":"JavaScript 공부기 ~ this, bind, apply","slug":"2016-9-02-a-thisapply","date":"2016-09-02T02:52:00.000Z","updated":"2016-09-26T16:05:18.000Z","comments":true,"path":"2016/09/02/2016-9-02-a-thisapply/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/02/2016-9-02-a-thisapply/","excerpt":"","text":"포인트 This의 사용 객체의 소속인 메소드의 this는 그 객체를 가르킨다. 아무것도 없을 경우는 window객체 Bind bind는 어떤 객체에 종속되어 있는 함수의 this의 문맥을 명시적으로 변경시키기 위해서 사용한다. Apply apply는 일시적으로 어떠한 함수를 다른 객체에서 사용할 수 있도록 하기 위해서 사용한다. Real codeThis 예제12345678910111213141516171819const userDB = &#123; findUser: function(id,password)&#123; if (!this.allUsers[id] || this.allUsers[id]['password'] != password) &#123; return false &#125; else &#123; return true &#125; &#125;, allUsers: &#123; admin: &#123; password: '123' &#125;, nersery: &#123; password: '123123' &#125;, lionking: &#123; password: '123' &#125; &#125; Bind예제React Native 공부기1 ~ bind 편 참조 Apply예제123456789101112131415161718var o = &#123;&#125;var p = &#123;&#125;function func()&#123; switch(this)&#123; case o: document.write('o&lt;br /&gt;'); break; case p: document.write('p&lt;br /&gt;'); break; case window: document.write('window&lt;br /&gt;'); break; &#125;&#125;func();func.apply(o);func.apply(p); 참조 생활코딩 this","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"Grammar","slug":"Grammar","permalink":"https://voidsatisfaction.github.io/tags/Grammar/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}]},{"title":"Give It Five Minutes","slug":"2016-8-26-a-giveItFiveMinutes","date":"2016-08-26T02:52:00.000Z","updated":"2016-09-26T15:44:15.000Z","comments":true,"path":"2016/08/26/2016-8-26-a-giveItFiveMinutes/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/26/2016-8-26-a-giveItFiveMinutes/","excerpt":"","text":"출처Give It Five Minutes 내가 읽은 2016최고의 글이다. 언제나 마음속에 내 철학으로 새겨둬야지. 이곳에 올린 이유는, 계속 마음에 품기 위해서. 그리고 이렇게 좋고 멋있는 글이 사라질까 두려워서. Give it five minutesI used to be a hothead. Whenever anyone said anything, I’d think of a way to disagree. I’d push back hard if something didn’t fit my world-view. It’s like I had to be first with an opinion — as if being first meant something. But what it really meant was that I wasn’t thinking hard enough about the problem. The faster you react, the less you think. Not always, but often. It’s easy to talk about knee jerk reactions as if they are things that only other people have. You have them too. If your neighbor isn’t immune, neither are you. This came to a head back in 2007. I was speaking at the Business Innovation Factory conference in Providence, RI. So was Richard Saul Wurman. After my talk Richard came up to introduce himself and compliment my talk. That was very generous of him. He certainly didn’t have to do that. And what did I do? I pushed back at him about the talk he gave. While he was making his points on stage, I was taking an inventory of the things I didn’t agree with. And when presented with an opportunity to speak with him, I quickly pushed back at some of his ideas. I must have seemed like such an asshole. His response changed my life. It was a simple thing. He said “Man, give it five minutes.” I asked him what he meant by that? He said, it’s fine to disagree, it’s fine to push back, it’s great to have strong opinions and beliefs, but give my ideas some time to set in before you’re sure you want to argue against them. “Five minutes” represented “think”, not react. He was totally right. I came into the discussion looking to prove something, not learn something. This was a big moment for me. Richard has spent his career thinking about these problems. He’s given it 30 years. And I gave it just a few minutes. Now, certainly he can be wrong and I could be right, but it’s better to think deeply about something first before being so certain you’re right. There’s also a difference between asking questions and pushing back. Pushing back means you already think you know. Asking questions means you want to know. Ask more questions. Learning to think first rather than react quick is a life long pursuit. It’s tough. I still get hot sometimes when I shouldn’t. But I’m really enjoying all the benefits of getting better. If you aren’t sure why this is important, think about this quote from Jonathan Ive regarding Steve Jobs’ reverence for ideas: And just as Steve loved ideas, and loved making stuff, he treated the process of creativity with a rare and a wonderful reverence. You see, I think he better than anyone understood that while ideas ultimately can be so powerful, they begin as fragile, barely formed thoughts, so easily missed, so easily compromised, so easily just squished. That’s deep. Ideas are fragile. They often start powerless. They’re barely there, so easy to ignore or skip or miss. There are two things in this world that take no skill: 1. Spending other people’s money and 2. Dismissing an idea. Dismissing an idea is so easy because it doesn’t involve any work. You can scoff at it. You can ignore it. You can puff some smoke at it. That’s easy. The hard thing to do is protect it, think about it, let it marinate, explore it, riff on it, and try it. The right idea could start out life as the wrong idea. So next time you hear something, or someone, talk about an idea, pitch an idea, or suggest an idea, give it five minutes. Think about it a little bit before pushing back, before saying it’s too hard or it’s too much work. Those things may be true, but there may be another truth in there too: It may be worth it.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Callback / Clojure / Continuation","slug":"2016-8-25-a-cbcjcn","date":"2016-08-25T02:52:00.000Z","updated":"2016-09-26T16:04:50.000Z","comments":true,"path":"2016/08/25/2016-8-25-a-cbcjcn/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/25/2016-8-25-a-cbcjcn/","excerpt":"","text":"배경콜백과 클로저는 JavaScript를 배우거나 OpenGL에서 본 개념이다.계속은 The Little Schemer에서 본 개념인데 너무 헷갈려서 정리해 놓는다. 계속 때문에 머리가 터질 것 같다 참조 히오키 선생님의 스킴(일문) 継続 JavaScript정리 리터럴부터 클로저까지 나무위키 포인트 콜백 함수에 인자로 넘겨지는 함수 함수에 인자로 넘겨지므로써 그 함수에 따른 기능을 하도록 한다. ex) Nodejs에서 req res에서의 콜백, OpenGL에서의 keyfuc콜백 클로저 클로저는 함수가 선언될 당시의 환경을 기억했다가 나중에 호출되었을때 원래의 환경에 따라 수행되는 함수이다. 계속 actor(lamda function)가 값과 처리방식을 다음 actor에 넘겨준다. 다음 actor은 값을 다른 actor에 넘겨주거나 처리하거나 할 수 있다. 콜백예시1234567891011121314151617//메인 프로그램function MainProgram &#123; var arg; LibFunc(arg, CallbackFunc);&#125;//콜백 함수function CallbackFunc(result) &#123; //result 이용&#125;//라이브러리 함수function LibFunc(arg, callback) &#123; var data; // 작업수행 callback(data);&#125; 클로저예시12345678910111213function outer() &#123; var x=0; return function() &#123; return ++x; &#125;&#125;var x=-1;var f= outer();console.log(x); // -1console.log(f()); //1console.log(f()); //2console.log(f()); //3 예시2 : 초기화12345678910111213function outer() &#123; var x=0; return function()&#123; return ++x; &#125;&#125;var x=-1;outer(); //function()&#123; return ++x; &#125;console.log(x); // -1console.log(outer()()); //1console.log(outer()()); //1console.log(outer()()); //1 예시3 : 클로저 인스턴스123456789101112131415161718function outer() &#123; var x=0; return function() &#123; return ++x; &#125;&#125;var x=-1;var f= outer(); //인스턴스 하나를 선언하는 효과다!!var g= outer(); //이렇게 하면 별도의 인스턴스로 생성된다.console.log(x); // -1console.log(f()); //1console.log(f()); //2console.log(f()); //3console.log(g()); //1 //새롭게 1부터 시작하는 것을 볼 수 있다.console.log(g()); //2console.log(g()); //3 클로저는 비공개 내부 변수를 갖는 함수 인스턴스 생성자이다. 클로저로 생성한 독립된 변수 공간을 가진 인스턴스를 클로저 인스턴스라고 한다. Q) 근데 결국 클로저를 어따가 쓰는거지? 계속12345(define fact (lambda n c) (if (= n c 1 ) (fact (- n 1) (lambda (a) (c (* n a)))))))","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}]},{"title":"프로그래밍 공부에 도움이 되는 사이트","slug":"3018-8-18-c-ProgrammingSite","date":"2016-08-25T02:52:00.000Z","updated":"2016-11-19T05:13:15.000Z","comments":true,"path":"2016/08/25/3018-8-18-c-ProgrammingSite/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/25/3018-8-18-c-ProgrammingSite/","excerpt":"","text":"프로그래밍(주로 웹) 공부에 도움이 되는 사이트를 모아보았습니다. 웹 기초웹의 기초적인 부분을 배울 수 있는 사이트들 입니다. 생활코딩Codelion멋쟁이 사자처럼CodecademyCss 레이아웃을 배웁시다웹 기본기초보다는 약간 더 자신있는 분들을 위하여. NodeJS Node School Ruby on Rails 초보자를 위한 레일스 가이드북 - RORLAB 알고리즘Euler Project(오일러 프로젝트 한글)Euler Project(영문)백준 온라인 judgeGoogle codejamTop Coder해킹 / 보안해커스쿨webhacking.krToolsGitHub / GitGit간편 안내서Git 쉽게 따라 배우기Vim Adventure좋은 블로그 / 팟캐스트나는 프로그래머다More Agile 보다 나은 개발자가 되기 위하여쪼꼬니 님의 블로그(웹디자인에 참고. 내용정리가 잘되어있음)기타Google Power Search","categories":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}],"tags":[{"name":"프로그래밍 교육","slug":"프로그래밍-교육","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍-교육/"}],"keywords":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}]},{"title":"React Native 공부기 1 ~ bind","slug":"2016-8-24-b-rn","date":"2016-08-24T12:52:00.000Z","updated":"2016-09-26T15:38:17.000Z","comments":true,"path":"2016/08/24/2016-8-24-b-rn/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/24/2016-8-24-b-rn/","excerpt":"","text":"포인트bind는 this의 scope를 제어하기 위한 메소드이다. Real codeCore 부분1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default class Stopwatch extends Component &#123; componentWillMount() &#123; this.setState(&#123; mainTime: 0, subTime: 0, timerOn: false, &#125;) &#125; render() &#123; console.log(this.state) return ( &lt;View&gt; &lt;Buttons startTime=&#123;this._startTime&#125; stopTime=&#123;this._stopTime&#125; stopWatch=&#123;this&#125;/&gt; &lt;/View&gt; ); &#125; _startTime()&#123; if (!this.state.timerOn)&#123; var timer = setInterval(() =&gt; &#123; let mainTime = this.state.mainTime let subTime = this.state.subTime this.setState(&#123; mainTime: mainTime + 1, subTime: subTime + 1, &#125;) &#125;, 100) this.setState(&#123; timer: timer, timerOn: true, &#125;) &#125; &#125; _stopTime() &#123; clearInterval(this.state.timer) this.setState(&#123; timerOn: false, &#125;) &#125;&#125; 위의 코드에서 주목할 부분은 Buttons라는 컴포넌트에 stopWatch={this}즉,props를 이용하여 this 전체를 건네주고 있다는 점이다. Buttons 컴포넌트1234567891011121314151617181920212223class Buttons extends Component &#123; render() &#123; return ( &lt;View style=&#123;day1Style.buttons&#125;&gt; &lt;TouchableOpacity style=&#123;day1Style.button&#125; onPress=&#123;this.props.startTime.bind(this.props.stopWatch)&#125;&gt; &lt;Text&gt; start &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity style=&#123;day1Style.button&#125; onPress=&#123;this.props.stopTime.bind(this.props.stopWatch)&#125;&gt; &lt;Text&gt; End &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125; 그리고 Buttons라는 component를 보면 TouchableOpacity의 onPress속성에서this.props.startTime.bind(this.props.stopWatch)로 되어있는것을 알 수 있다. 여기서 왜 bind(this.props.stopWatch)를 해야만 하는가 하면그냥 this.props.startTime을 실행해버리면startTime함수 안의 this가 Buttons의 this가 되어버리기 때문이다. 우리가 제어하고 싶은 state는 Stopwatch component에 존재하기 때문에startTime함수의 this의 scope를 Stopwatch에 bind시켜줄 필요가 있다. 따라서 bind(this.props.stopWatch) 즉, bind(Stopwatch component 전체)로 this를 고정시켜줌으로써이러한 문제를 해결시켜줄 수 있다. 참조 RN JS 연습 - 3 Use of the JavaScript ‘bind’ method","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"Nodejs 공부기 3 ~ Web Application만들기","slug":"2016-8-24-a-nodestudy3","date":"2016-08-24T02:52:00.000Z","updated":"2016-09-26T15:37:05.000Z","comments":true,"path":"2016/08/24/2016-8-24-a-nodestudy3/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/24/2016-8-24-a-nodestudy3/","excerpt":"","text":"선생님생활코딩 Nodejs 배운 내용들 우리는 비게 오게 해달라 오지 않게 해달라고 기도한다. 하지만 진정한 기도는 비가 와도 오지 않아도 자기자신이 흔들리지 않게 해달라는 해탈을 위한 기도이다. 고생고생해서 CRUD하나 만들었는데 확실히 Nodejs가 편리한 면이 있다.그러나 앱을 만드는데에 있어서 중요한 것은한번에 다 하려고 하지 않고 하나한 차근차근 해나가는 것이다.즉, 기획을 완벽히 하고 앱을 제작하자. 여기서 기획이라 함은 어떠한 객체가 어떻게 작용하는지, 어떤 흐름으로 작동하는지를명확히 한 것을 의미한다. 백날 디버깅하는 것 보다 한 번 기획을 잘하는 것이 효율적이다. Real code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const express = require('express')const app = express()const bodyParser = require('body-parser')const Oriento = require('oriento');const server = Oriento(&#123; host: 'localhost', port: 2424, username: 'root', password: '***' // You should save password on config file for proper security&#125;);var db = server.use('o2')console.log('Using database: ' + db.name)app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.locals.pretty = trueapp.set('views', './views')app.set('view engine', 'pug')app.get('/topic/add', (req, res) =&gt; &#123; res.render('add')&#125;)app.post('/topic/add', (req, res) =&gt; &#123; const title = req.body.post_title const name = req.body.post_name const description = req.body.post_description const sql = 'INSERT INTO topic (title, author, description) VALUES(:title, :name, :description)' db.query(sql, &#123;params: &#123;title: title, name: name, description: description&#125;&#125;).then((result) =&gt; &#123; console.log(result) const id = encodeURIComponent(result['@rid']) res.redirect('/topic/') &#125;)&#125;)app.get('/topic/:id/edit', (req, res) =&gt; &#123; const id = decodeURIComponent(req.params.id) const sql = 'SELECT FROM topic where @rid=:rid' db.query(sql, &#123;params: &#123;rid: id&#125;&#125;).then((topic) =&gt; &#123; console.log(topic) res.render('edit', &#123;topic: topic[0]&#125;) // Be careful!! topic[0] &#125;)&#125;)app.post('/topic/:id/edit', (req, res) =&gt; &#123; const rid = decodeURIComponent(req.params.id) const title = req.body.post_title const name = req.body.post_name const description = req.body.post_description const sql = `UPDATE topic SET title=:title, author=:name, description=:description WHERE @rid=:rid` //no comma plz db.query(sql, &#123; params: &#123; rid: rid, title: title, name: name, description: description&#125; &#125;).then((topic) =&gt; &#123; console.log('edit complete') res.redirect('/topic/' + encodeURIComponent(req.params.id)) &#125;)&#125;)app.get('/topic/:id/delete', (req, res) =&gt; &#123; const rid = decodeURIComponent(req.params.id) const sql = 'DELETE FROM topic WHERE @rid=:rid' db.query(sql, &#123;params: &#123;rid: rid&#125;&#125;).then((result) =&gt; &#123; console.log('delete successfully') res.redirect('/topic/') &#125;)&#125;)app.get(['/topic', '/topic/:id'], (req, res) =&gt; &#123; const sql = 'SELECT FROM topic' db.query(sql).then((results) =&gt; &#123; if (req.params.id) &#123; const id = decodeURIComponent(req.params.id) const sql2 = 'SELECT FROM topic WHERE @rid=:rid' // rid should be placed inside of next's params! db.query(sql2, &#123;params: &#123;rid: id&#125;&#125;).then((topic) =&gt; &#123; console.log(topic) res.render('topic', &#123;topic: topic[0], topics: results&#125;) &#125;) &#125; else &#123; res.render('topic', &#123;topic: &#123;title: 'Welcome!', name: 'Master', description: 'Practicing'&#125;, topics: results&#125;) &#125; &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log('Server connected at 3000!')&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://voidsatisfaction.github.io/tags/Nodejs/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}]},{"title":"Nodejs 공부기 2","slug":"2016-8-23-c-nodestudy2","date":"2016-08-23T14:59:00.000Z","updated":"2016-09-26T15:36:03.000Z","comments":true,"path":"2016/08/23/2016-8-23-c-nodestudy2/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/23/2016-8-23-c-nodestudy2/","excerpt":"","text":"선생님생활코딩 Nodejs 배운 내용들File Based Web App Get / Post Get : Using URL Post : No URL bodyParser Web App Making CR(UD) Removing Overlapped Expression File Uploading Multer ETC Nodejs Auto-restart(supervisor module) Real codeApp.js(CR,File upload)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const express = require('express')const bodyParser = require('body-parser')const multer = require('multer')const _storage = multer.diskStorage(&#123; destination: (req, file, cb) =&gt; &#123; cb(null, 'uploads/') &#125;, filename: (req, file, cb) =&gt; &#123; cb(null, file.originalname + '-' + Date.now()) &#125;&#125;)const upload = multer(&#123; storage: _storage &#125;)const fs = require('fs')const app = express()app.use('/user', express.static('uploads')) // uploads에 있는 파일들을 /user라는 url을통해서 서비스 하겠다. (유저가 갖고 갈 수 있게 함.)app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.set('views', './views')app.set('view engine', 'pug')app.get('/', (req, res) =&gt; &#123; res.send('hi fool!' )&#125;)app.get('/upload', (req, res) =&gt; &#123; res.render('upload')&#125;)// Middle ware first(processing)app.post('/upload', upload.single('userfile'), (req, res) =&gt; &#123; console.log(req.file) res.send('Uploaded : ' + req.file.filename)&#125;)app.get('/topic/new', (req, res) =&gt; &#123; fs.readdir('data', (err, files) =&gt; &#123; if (err) &#123; console.log(err) res.status(500).send('Internal Server Error') &#125; res.render('new', &#123; topics: files&#125;) &#125;)&#125;)app.get(['/topic', '/topic/:id'], (req, res) =&gt; &#123; fs.readdir('data', (err, files) =&gt; &#123; if (err) &#123; console.log(err) res.status(500).send('Internal Server Error') &#125; const id = req.params.id if (id) &#123; fs.readFile(`data/$&#123;id&#125;`, 'utf8', (err, data) =&gt; &#123; if (err) &#123; console.log(err) res.status(500).send('Internal Server Error') &#125; res.render('view', &#123; title: id, topics: files, description: data&#125;) &#125;) &#125; else &#123; res.render('view', &#123; topics: files, title: 'Welcome', description: 'Hello, JavaScript for server.' &#125;) &#125; &#125;)&#125;)app.post('/topic', (req, res) =&gt; &#123; const title = req.body.title const description = req.body.description fs.writeFile(`data/$&#123;title&#125;`,description, (err) =&gt; &#123; if (err) &#123; res.status(500).send('Internal Server Error!') &#125; res.redirect('/topic') &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log('Connected at 3000port!')&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://voidsatisfaction.github.io/tags/Nodejs/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}]},{"title":"Scheme의 아름다움 ~ Continuation","slug":"2016-8-23-b-schemestudy","date":"2016-08-23T14:52:00.000Z","updated":"2016-09-26T15:34:04.000Z","comments":true,"path":"2016/08/23/2016-8-23-b-schemestudy/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/23/2016-8-23-b-schemestudy/","excerpt":"","text":"선생님The Little Schemer 배운 내용들 lambda 함수의 return값으로 함수를 건네줄 수 있다. 그 함수는 lambda함수를 이용해서 건네줄 수 있다. Collecter 함수가 여러 값을 나타낼 수 있도록 도와준다. 값의 Collect 아직 완벽하지 이해하지는 못했으나 정말 아름다워 보인다. Real code예제11234567891011121314151617181920212223242526272829303132333435363738#| Remeber more than two value at a time |#(define (multiinsertLR new oldL oldR lat) (cond ((null? lat) '()) ((eq? oldL (car lat)) (cons new (cons oldL (multiinsertLR new oldL oldR (cdr lat))))) ((eq? oldR (car lat)) (cons oldR (cons new (multiinsertLR new oldL oldR (cdr lat))))) (else (cons (car lat) (multiinsertLR new oldL oldR (cdr lat))))))(define (multiinsertLR&amp;co new oldL oldR lat col) (cond ((null? lat) (col '() 0 0)) ((eq? oldL (car lat)) (multiinsertLR&amp;co new oldL oldR (cdr lat) (lambda (newlat L R) (col (cons new (cons oldL newlat)) (+ L 1) R)))) ((eq? oldR (car lat)) (multiinsertLR&amp;co new oldL oldR (cdr lat) (lambda (newlat L R) (col (cons oldR (cons new newlat)) L (+ R 1))))) (else (multiinsertLR&amp;co new oldL oldR (cdr lat) (lambda (newlat L R) (col (cons (car lat) newlat) L R))))))(multiinsertLR&amp;co 'salty 'fish 'chips '(chips and fish or fish and chips) (lambda (lat a b) (cons a (cons b lat)))) 해설만약 위의 multiinsertLR&amp;co함수가(multiinsertLR&amp;co ‘hi ‘animal ‘plant ‘(hello world) col)이렇게 실행된다고 하자. (여기서 col은 아직 미정의) 그러면, 조건 분기에서 다음이 실행된다. (car lat)인 ‘hello는 oldL, oldR과도 다르므로else 이후의 내용이 실행된다.그런데 여기서 바로 (multiinsertLR&amp;co)함수를 인수만 바꿔서 실행한다.특히 바뀌는 것은 col만 바뀌므로 그쪽에만 집중해서 보기로 하자. 두 번째 multiinsertLR&amp;co의 실행에서col =&gt; (lambda (newlat L R) (col (cons (car lat) newlat) L R))즉, 이는 (col (newlat L R) (col (cons (car lat) newlat) L R))과도 동일하다. 풀어서 얘기하자면, 두번째 multiinsertLR&amp;co는 col에 대한부분이(col (newlat L R) (col (cons (car lat) newlat) L R)) 이렇게 변하는 것이며,(car lat)이 ‘hello 였으므로,(col (newlat L R) (col (cons ‘hello newlat) L R))이 col 인자로 넘어가게 된다. 다음 프로세스(car lat)인 ‘world는 oldL, oldR과도 다르므로else 이후의 내용이 실행된다.그리고 마찬가지로 col만 변화가 되므로 col에만 집중해서 보자. 세번째 multiinsertLR&amp;co의 실행에서col =&gt; (lambda (newlat L R) (col (cons ‘world newlat) L R))여기서 주목해야할 것은 화살표 왼쪽의 col과 오른쪽의 col을 구별하는 것이다.왼쪽의 col은 앞으로 col의 자리에 넘겨주게 될 함수의 인자를 의미하는 것이며,오른쪽의 col은 현재 실행되는 함수의 col을 말하는 것이다. 여기서 우리는 현재 실행되는 함수의 col이 전multiinsertLR&amp;co에서 인자로서 받아온(col (newlat L R) (col (cons ‘hello newlat) L R))이 된다는 것을 알기때문에우리가 다음 multiinsertLR&amp;co에 전해줄 col은col(전해줄 col) =&gt; (lambda (newlat L R) (col(가장 처음의 col) (cons ‘hello (cons ‘world newlat)) L R)) 이렇게 됨을 알 수있다. 마지막 multiinsertLR&amp;co를 실행하면(null? lat)이 참이므로(col ‘() 0 0)이 실행되는데 col은 위에서 받아온 그대로이므로(col (cons ‘hello (cons ‘world ‘())) L R)이 된다.즉, 최종 결과는 (col (hello world) L R)이며,이는 하나의 함수가 리스트를 이용하여 다양한 값을 저장할 수 있다는 것을 의미한다. 예제2 (p.s 정말 아름다운 코드다)1234567891011121314151617181920212223242526272829303132333435363738(define (atom? s) (and (not (pair? s)) (not (null? s))))(define (evens-only* l) (cond ((null? l) '()) ((and (atom? (car l)) (even? (car l))) (cons (car l) (evens-only* (cdr l)))) ((atom? (car l)) (evens-only* (cdr l))) (else (cons (evens-only* (car l)) (evens-only* (cdr l))))))(define (evens-only*&amp;co l col) (cond ((null? l) (col '() 1 0)) ((and (atom? (car l)) (even? (car l))) (evens-only*&amp;co (cdr l) (lambda (newl mul sum) (col (cons (car l) newl) (* (car l) mul) sum)))) ((atom? (car l)) (evens-only*&amp;co (cdr l) (lambda (newl mul sum) (col newl mul (+ (car l) sum))))) (else (evens-only*&amp;co (car l) (lambda (al ap as) (evens-only*&amp;co (cdr l) (lambda (dl dp ds) (col (cons al dl) (* ap dp) (+ as ds)))))))))(evens-only*&amp;co '((9 1 2 8) 3 10 ((9 9) 7 6) 2) (lambda (l mul sum) (cons sum (cons mul l)))) 해설머리로는 이해했으나 가슴으로는 이해하지 못했다. 결국, else이후의 구문이 문제가 되는 것인데여기서 포인트는 아래와 같다. 무엇이 먼저 실행되는가? 12345678(else (evens-only*&amp;co (car l) (lambda (al ap as) (evens-only*&amp;co (cdr l) (lambda (dl dp ds) (col (cons al dl) (* ap dp) (+ as ds))))))))) 만약 우리가 위의 원래의 함수를 어떤 리스트를 넣어서 실행했다고생각한다면 else이후의 내용이 실행되었을때 어떤것들이 어떤순서로 실행될까? 답은 뒤에위치한 앞에있는 evens-only*&amp;co의 부분이 먼저 실행된다는 것이다 그렇다는 얘기는 만일 l이 ‘((hi nice to meet you) my name is amy) 인 경우에(car l)인 리스트가 evens-only*&amp;co의 함수에 input되는 것이 아니라뒷부분의 my 이후의 (cdr l)부분이 먼저 col에 저장된다. 그리고 atom들의 collect가 끝나서야 (hi nice to meet you)부분이 collect되어 합쳐진다.","categories":[{"name":"Scheme","slug":"Scheme","permalink":"https://voidsatisfaction.github.io/categories/Scheme/"},{"name":"Schemer series","slug":"Scheme/Schemer-series","permalink":"https://voidsatisfaction.github.io/categories/Scheme/Schemer-series/"}],"tags":[{"name":"Scheme","slug":"Scheme","permalink":"https://voidsatisfaction.github.io/tags/Scheme/"}],"keywords":[{"name":"Scheme","slug":"Scheme","permalink":"https://voidsatisfaction.github.io/categories/Scheme/"},{"name":"Schemer series","slug":"Scheme/Schemer-series","permalink":"https://voidsatisfaction.github.io/categories/Scheme/Schemer-series/"}]},{"title":"Nodejs 공부기 1","slug":"2016-8-23-a-nodestudy","date":"2016-08-23T02:52:00.000Z","updated":"2016-11-16T06:35:10.000Z","comments":true,"path":"2016/08/23/2016-8-23-a-nodestudy/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/23/2016-8-23-a-nodestudy/","excerpt":"","text":"선생님생활코딩 Nodejs 배운 내용들Basics Nodejs? Client and Server NPM npm init =&gt; package.json 파일 작성 npm install underscore (--save) =&gt; node_modules폴더에 underscore추가, –save는 package.json에 dependencies추가 Example : Uglify, Express, Underscore Callback Function 코드상에서 직접 호출되는 것이 아니고, 누군가가 호출하는 함수. (정의가 완벽하지 못한 것 같다.) 주로 lambda를 이용해서 구현. 함수도 데이터이기 때문에 함수가 함수를 인자로 받을 수 있는 것을 이용. Sync, Async 빨래/설거지/청소, 100만명에게 이메일 보내기 Relationship JS and Nodejs Module and NPM Structure of App.js Express API Static, Dynamic Static : html, image, … =&gt; 실시간 동기화, 편집이 쉬움 =&gt; ./public/htmlfile or img Dynamic : js code in controller(call back) =&gt; 편집은 어려우나 동적으로 제어가능 =&gt; app.js Template Engine(Jade) app.set(&#39;view engine&#39;, &#39;jade&#39;) app.set(&#39;views&#39;, &#39;./views&#39;) Jade만의 형식이 따로 있음 Query String URL을 이용한 정보의 전달 http://a.com/topic?id=1 http://a.com/topic/id/1 (semantic) Real codeApp.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const express = require('express')const app = express()app.locals.pretty = trueapp.set('view engine', 'jade')app.set('views', './views')app.use(express.static('public')) // static file serviceapp.get('/topic/:id', (req, res) =&gt; &#123; const topics = [ 'javascript is ...', 'Nodejs is ...', 'Express is ...' ] const output = ` &lt;a href=\"/topic/0\"&gt;javascript&lt;/a&gt;&lt;br&gt; &lt;a href=\"/topic/1\"&gt;nodejs&lt;/a&gt;&lt;br&gt; &lt;a href=\"/topic/2\"&gt;express&lt;/a&gt;&lt;br&gt; $&#123;topics[req.params.id]&#125; ` res.send(output)&#125;)app.get('/topic/:id/:mode', (req, res) =&gt; &#123; res.send(`$&#123;req.params.id&#125;,$&#123;req.params.mode&#125;`)&#125;)app.get('/template', (req, res) =&gt; &#123; res.render('temp', &#123;time: Date(), _title: 'jade'&#125;)&#125;)app.get('/', (req, res) =&gt; &#123; res.send('Hello this is my main page')&#125;)app.get('/dynamic', (req, res) =&gt; &#123; var lis = '' for(var i=0; i&lt;5; i++)&#123; lis += '&lt;li&gt;coding&lt;/li&gt;' &#125; var time = Date() res.send( ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hello Dynamic!!!! &lt;ul&gt; $&#123;lis&#125; &lt;/ul&gt; $&#123;time&#125; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ` )&#125;)app.get('/route', (req, res) =&gt; &#123; res.send('&lt;img src=\"/five_minutes.png\" /&gt;')&#125;)app.get('/login', (req, res) =&gt; &#123; res.send( `&lt;h1&gt;Practice&lt;/h1&gt; &lt;p&gt;What are you doing now?&lt;/p&gt;` )&#125;)app.listen(3000, () =&gt; &#123; console.log('Connected at 3000 port!')&#125;) Template.jade123456789html head title= _title body h1 Hello world! ul -for(var i=0; i&lt;5; i++) li coding div= time 궁금한 것들 한 컴퓨터에 여러 서버가 존재할 경우, 만일 서버의 포트가 겹치면 어떻게 되는가? 왜 콜백이 존재해야 하는가? (애초에 콜백이란 무엇인가?) maybe 중복의 제거?(기능적 중복) Ruby는 멀티스레드를 지원하는가? Nodejs는 싱글스레드인데 어떻게 비동기가 가능한 것인가?(비동기의 원리) const http = require(&#39;http&#39;) 의 정확한 의미? (http모듈 객체를 http라는 상수에 넣는다? 그럼 모듈 객체는 뭐지? 인스턴스인가?) Nodejs의 기능을 구현하기 위한 ‘그릇’ 혹은 ‘배경’ = JavaScript 라고 이해해도 되는가? RESTful? Semantic URL? Node의 View는 어떻게 꾸며주는가? Angular? Jade?","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://voidsatisfaction.github.io/tags/Nodejs/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}]},{"title":"세상은 넓고 대단한 사람은 많다.","slug":"2016-8-21-b-justbecause","date":"2016-08-21T12:52:00.000Z","updated":"2016-09-26T15:31:06.000Z","comments":true,"path":"2016/08/21/2016-8-21-b-justbecause/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/21/2016-8-21-b-justbecause/","excerpt":"","text":"모덴 웹을 위한 Node.js프로그래밍 이라는 책을 사두기만 하고 처음 펴 봤는데 작가님의 blog가 있길래 한 번 들어가 봤다. 그랬더니 웬걸 정말 대단하신 분이다. 하하. (왜 대단하신 분인지는 블로그에 들어가 보시면 압니다.) 대놓고 얘기하자면 나도 작가님 이상이 되고싶다! 프로그래밍을 시작한지 이제 1년인데 욕심이 너무 많은거 아니냐고 생각할 수도 있지만 뭐, 이게 내가 열심히 하는 원동력이 된다고 생각한다. 그리고 수준이 너무 많이 차이난다고 생각하여 자괴감을 느낄 필요도 없다. 나는 그냥 천천히 내 생각대로 내가 하고싶은대로 하나하나 해나가야지. 힘내자! 아자아자! ^ ^","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"후배의 좋은 가르침","slug":"2016-8-21-a-learning","date":"2016-08-21T02:52:00.000Z","updated":"2016-09-26T15:30:34.000Z","comments":true,"path":"2016/08/21/2016-8-21-a-learning/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/21/2016-8-21-a-learning/","excerpt":"","text":"포인트 백엔드의 본질은 서버를 구성하는 틀을 이해하는 것이다(ex 로그인) Connecting the dots 자신이 무엇을 좋아하는지, 하고 싶은지, 잘 할 수 있는지에 대한 자기분석이 중요하고, 그것을 잘 살려 나갈 수 있어야 한다 진정한 도전정신 오늘은 후배를 만났다. 사실 그는 대학에 늦게 들어온 것 뿐이지, 컴퓨터 공학과 웹 공부에 대해서는 나에게 아주 좋은 선배다. 그 후배를 만나면 언제나 큰 자극을 받을 뿐더러 많은 것을 깨닫게 해준다. 오늘은 그 후배와의 만남에서 느낀 몇가지에 대해서 간단히 써 보려고 한다. 백엔드의 본질은 서버를 구성하는 틀을 이해하는 것이다말 그대로 후배는 웹 개발에 있어서 백엔드의 본질은 서버를 구성하는 틀을 이해하는 것이라고 했다. 서버의 구조란 Ruby On Rails를 예로 들어보면 다음과 같다. 위와 같이 Rails가 어떤 식으로 돌아가는지 Data Flow를 이해하는 것 또한 서버를 구성하는 틀을 이해하는 방식의 하나이다. 여기서 한가지 포인트는 반드시 서버 내부의 Data Flow를 이해하는 것만이 서버를 구성하는 틀을 이해하는 것이 아니라는 것이다. 서버를 다양한 각도에서 볼 수 있어야 한다. 서버를 ‘기능’의 관점에서 이해할 수도 있어야 한다. 예를들면, 서버에는 로그인, DB와의 연동 등등.. 다양한 기능이 탑재되어 있다. 이러한 ‘기능’의 시선에서 서버를 볼 줄도 알아야한다. 그리고 서버에 대한 이해가 깊어진 이후에는 각각의 상황에서 구글 선생님의 도움을 청하면 된다. Connecting the dots‘Connecting the dots’라는 말은 ‘Give it five minutes’와 더불어 내 삶의 신조와 같다. 이 말은 스티브 잡스가 스탠포드 연설에서 한 말인데, 그 뜻은 ‘지금 하는 것이 별로 도움이 되지 않는 것 처럼 보이더라도 그것이 점과 점을 연결하듯이 언젠가 무엇인가에 연결되어 도움이 될 수도 있다’ 라는 것이다.(여담이지만 스티브 잡스의 스탠포드 연설은 정말 볼 만한 가치가 있다.) 오늘 마침 후배가 자신이 참 좋아하는 말이라며 Connecting the dots에 대해서 언급했는데, 오랜만에 만난 친구를 보는 것과 같은 반가움을 느꼈다. 자신이 무엇을 좋아하는지, 하고 싶은지, 잘 할 수 있는지에 대한 자기분석이 중요하고, 그것을 잘 살려 나갈 수 있어야 한다사실 나는 이 부분이 조금 약하다고 생각한다. 물론 성격차이 일 수 있겠지만, 나는 이성적으로 냉철하게 나를 분석하고 계획을 세워서 생활하기보다는 물에 내 몸을 맡기듯이 내가 직관적으로 좋아하는 무엇인가를 자연스럽게 계속해서 추구해나가는 타입이다. 하지만 세상일들이 무릇 그렇듯 균형이 참 중요한 것 같다. 항상 직관적으로만 살아가면 냉철함을 잊기 쉽고 항상 이성적으로만 살아가면 뜨거운 열정을 잊기 쉽다. 직관과 이성의 조화가 중요하다고 생각한다. 이는 인간이나 기계나 매한가지인 듯 싶다. 직관을 배우려는 기계를 보면서 말이다. 진정한 도전정신단도직입적으로 나는 혼자서 무엇인가를 하는 것을 좋아한다. 이는, 내가 프로그래밍을 좋아하는 이유 중 하나이기도 하다. 하지만 후배는 정말 적극적으로 도전해나가는 모습이 참 멋있었다. 섬에 가서 인턴생들과 함께 기계팔을 만들어서 프로그래밍을 하거나, 스타트업에 참여해 CTO로서 적극적으로 도전해나가는 모습. 또, 그것에 그치지 않고 해커톤까지 열심히 참여하는 모습은 정말 대단하다고 느껴진다. 그래도 역시 나는 ‘나 다움’이 있다고 생각한다. 내가 혼자서 무엇인가를 하는 것을 좋아하는데 억지로 나가서 도전할 필요는 없다고 생각한다. 대신에 나 자신이 진정 도전하고 싶다는 생각이 들 때 두려움 없이 뛰쳐나갈 수 있는 마음가짐을 갖고 있는 것은 중요하다고 생각한다. 두려움과 그것을 극복할 의지. The only thing we have to fear is fear itself. 오늘 짧다면 짧고 길다면 긴 시간동안 이렇게 중요한 교훈을 느끼게 해주고 나를 한 발자국 더 나아게가 자극시켜준 후배에게 정말 감사하다는 말을 전해주고 싶다. 오늘은 기분이 참 좋은 날이다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Local Git에서 Git Hub로 push할 경우 permission deny문제","slug":"2016-8-19-a-found","date":"2016-08-19T12:52:00.000Z","updated":"2016-12-10T11:57:43.000Z","comments":true,"path":"2016/08/19/2016-8-19-a-found/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/19/2016-8-19-a-found/","excerpt":"","text":"배경Jekyll을 로컬에서 수정하고 싶어서 Github의 repository와의 연동을 시도했으나, 다음과 같은 에러 메세지가 떴다. 포인트Local에 저장되어있는 Keychain에서, Github.com의 account와 password를 현재 사용하는 깃허브의 계정으로 변환 과정123451) Mac에서 Keychain이라는 어플리케이션을 연다.2) github.com을 검색한다.3) 속성에서 account와 password를 현 github계정으로 바꿔준다.4) 원격 저장소의 git내용에 현 저장소에는 없는 내용이 있다면 git pull origin master 로 동기화 시켜준다.5) git push origin master 깨달은 것사실 생각해보면, git과 github를 연동하기 위해서는 github의 계정정보가 로컬에 반드시 있어야 한다. 그래야만 인증이 가능하기 때문이다.그렇기 때문에, permission denied 에러가 생겼다는 것은 그 계정과 연관이 깊을 가능성이 크고, 그것을 바꿀 생각을 해야하는데 단순히 git.username git.email 만 변경한다고 해서 인증 에러를 해결할 수는 없는 것이다. 역시 본질에 입각해서 생각하면 문제의 본질을 이해할 수 있다. 참조 Permission denied error and Keychain Access GitHub::Updating credentials from the OSX Keychain GItHub::Dealing with non-fast-forward errors","categories":[{"name":"Utils","slug":"Utils","permalink":"https://voidsatisfaction.github.io/categories/Utils/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://voidsatisfaction.github.io/tags/GitHub/"}],"keywords":[{"name":"Utils","slug":"Utils","permalink":"https://voidsatisfaction.github.io/categories/Utils/"}]},{"title":"교토대 정보학과를 붙고 나서...","slug":"2016-8-19-b-graduate","date":"2016-08-19T02:52:00.000Z","updated":"2016-09-26T15:59:10.000Z","comments":true,"path":"2016/08/19/2016-8-19-b-graduate/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/19/2016-8-19-b-graduate/","excerpt":"","text":"목차 자기소개 프로그래밍의 우주에 오신 것을 환영합니다! 왜 프로그래밍을 공부하게 되었는가? 어떻게 대학원을 준비했는가? 자기소개나는 2016년 8월 현재 교토대학교 경제학부 4학년에 재학중인 학생이다. 프로그래밍을 시작한 건, 대학교 3학년 여름방학이 시작될 무렵이었다. 왜 프로그래밍을 공부하게 되었는가?내가 처음 프로그래밍을 시작하게 된 계기는 막연한 호기심과 멋 때문이었다.일본 대학의 문과계열 학생은 세미나(연구실과 비슷한 느낌입니다.)에 참가하여 지도교수님 밑에서 지도교수님의 전문분야를 학습하는데, 나와 같은 경우는 “교토식 경영”으로 한국에서도 유명하신 스에마츠 치히로 교수님 밑에서 수학하게 되었다. 내가 속한 세미나는 Logical Thinking에 대한 연구를 하며, 단순히 전문지식을 배우는 것에서 끝나지 않고, 학생들끼리 그룹 토론을 하는 경우도 많았고, 다양한 배경의 학생들의 의견을 들으며 자극도 많이 받을 수 있는 환경에 있었다. 나는 그 세미나에서 처음으로 프로그래밍을 전문적으로 하는 사람을 접하게 되었다. 웨이트 트레이닝을 매우매우 좋아하는 선배였는데(나도 그 선배와 같이 웨이트에 참여하곤 했다.), 프로그래밍을 정말로 좋아하고 프로그래밍을 즐기는 것에대한 자부심이 있는 선배였다. 그 선배는 우리는 하지 못하는 무엇인가를 항상 “창조” 했다. 예를들어, “빵집의 매상을 올리는 방법을 생각하라”라는 문제를 해결하려고 할때, 나를 비롯한 다른 학생들이 “~~한 식으로 마케팅을 하거나, 비용을 절감하면 될 것같습니다.” 라고 할 때, 그 선배는,” ~~한 시스템을 직접 만들면 어때?” 와 같은 웹 지식을 배경으로 한 보다 구체적인 방안을 제시했고, 단순히 제시만 한 것이 아니라 실현까지 하므로써 매우 설득력이 높았다. 그때부터 그 선배의 프로그래밍이라는 능력이 참 멋있어보이고 “저 선배처럼 나도 저 선배처럼 한 번 프로그래밍을 공부해봐야겠다.”라는 생각을 하게되었고, 그것이 나의 프로그래밍에 관한 모든 것의 시작이었다. 프로그래밍의 우주에 오신 것을 환영합니다!그렇게 나는 프로그래밍의 우주를 탐험하기 시작했다. 가장 처음에, 일단 어디서 프로그래밍을 공부해야하지 몰라서, 네이버에 “프로그래밍 무료 강의” 라고 검색하여 운이 좋게도 egoing님이 운영하고 계신 생활코딩 이라는 사이트를 알게 되었다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"지킬에 관하여 알아낸 사실들","slug":"2016-8-18-a-jekyllfound","date":"2016-08-18T11:52:00.000Z","updated":"2016-09-26T15:53:58.000Z","comments":true,"path":"2016/08/18/2016-8-18-a-jekyllfound/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/18/2016-8-18-a-jekyllfound/","excerpt":"","text":"오늘 지킬에 대해서 알아낸 사실은 다음과 같다. Syntax highlight기능을 쓰기 위해서는 써야한다.12345678910112. ``` 앞뒤에 반드시 한 줄씩 띄워주어야 한다. 그렇지 않으면 잘못 인식된다.2. 내용 작성의 첫 줄은 부제목이다. 따라서 일정 길이 이상이 되면 자동으로 문법이 풀린다.3. github푸시 후 실제의 블로그에 적용되기 까지는 어느정도 시간이 필요하다### Syntax highlight기능 ###지킬에서는 하이라이트 기능으로서, Ruby의 Rough를 사용하는데, 그 사용법은\\```\\[언어명\\]\\","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"}]}]}
{"meta":{"title":"텅 빈 충만의 블로그","subtitle":"Ruby JavaScript Scheme을 사랑하는 초보 학생의 소박한 프로그래밍.","description":"즐거운 프로그래밍 세상, Hello World!","author":"텅 빈 충만(voidSatisfaction)","url":"https://voidsatisfaction.github.io"},"pages":[],"posts":[{"title":"나홀로 해커톤 시즌1","slug":"my-mini-hackerton-on-nf","date":"2016-11-16T03:24:03.000Z","updated":"2016-11-16T03:56:32.000Z","comments":true,"path":"2016/11/16/my-mini-hackerton-on-nf/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/16/my-mini-hackerton-on-nf/","excerpt":"","text":"기간교토대학교 NF기간(2016.11.18 ~ 11.23) 미니 해커톤 소개대학교 축제를 맞이하여 평소에 하지 못했던 개인 프로젝트를 진행해보자! 마음가짐무작정 코드부터 작성하지말고, 기획을 제대로 하자. 아키텍쳐를 설계해보자. 1. Make it markdown 웹페이지화 개요 : Make it markdown을 웹페이지화 시켜서 쓰기 편하게 하자. 기능 url입력하는곳에 입력하면 자동적으로 html파싱해서 markdown파일을 만들어준다. 광고도..? 기술 Nodejs herokuapp 2. NodeJS로 비서 봇 만들기 개요 : Mac내장 notes앱이랑 연동해서 Slack 비서봇을 만들자. 기능 매일아침 Todolist 알려주기(다음날 / 이번주 / 이번달) 학교 홈페이지 お知らせ에 새로운 글이 추가되었는지 확인. 기술 Nodejs 3. Snake게임 AI 만들기(희망사항) 개요 : c++로만든 Snake게임 AI를 만들어보자. 기능 길찾기 알고리즘(장애물 포함일 경우) 장애물 추가 메뉴 추가 기술 c++ 전부다 실행하는게 무리일 수 있으나 make-it-markdown웹페이지화 / slack봇만들기는 꼭 해보고싶다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"},{"name":"나홀로 해커톤","slug":"나홀로-해커톤","permalink":"https://voidsatisfaction.github.io/tags/나홀로-해커톤/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"React Native with 최신 자바스크립트 문법","slug":"react-native-javascript-environment","date":"2016-11-15T07:48:25.000Z","updated":"2016-11-15T08:23:01.000Z","comments":true,"path":"2016/11/15/react-native-javascript-environment/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/15/react-native-javascript-environment/","excerpt":"","text":"참조 JavaScript Environment - React Native babeljs.io Flowtype.org Object Spread esnext 고찰사부가 쓰던 모든 최신문법이 여기 있었다. 또한 React Native는 iOS simulator에서는 JavaScriptCore(Safari의 자바스크립트 엔진)를 사용하고, Chrome debugging에서는 V8엔진으로 따로 사용한다는 것을 알게 되었다. 여담 및 재미있는 코드object.assign() - MDN 1234567891011121314151617function test() &#123; let a = &#123; b: &#123;c:4&#125; , d: &#123; e: &#123;f:1&#125;&#125; &#125; let g = Object.assign(&#123;&#125;,a) let h = JSON.parse(JSON.stringify(a)); console.log(g.d) // &#123; e: &#123; f: 1 &#125; &#125; g.d.e = 32 console.log('g.d.e set to 32.') // g.d.e set to 32. console.log(g) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125; console.log(a) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125; console.log(h) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: &#123; f: 1 &#125; &#125; &#125; h.d.e = 54 console.log('h.d.e set to 54.') // h.d.e set to 54. console.log(g) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125; console.log(a) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125; console.log(h) // &#123; b: &#123; c: 4 &#125;, d: &#123; e: 54 &#125; &#125;&#125;test();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"JavaScript Spread Operator","slug":"javascript-spread-operator-study","date":"2016-11-15T05:21:56.000Z","updated":"2016-11-15T06:31:36.000Z","comments":true,"path":"2016/11/15/javascript-spread-operator-study/","link":"","permalink":"https://voidsatisfaction.github.io/2016/11/15/javascript-spread-operator-study/","excerpt":"","text":"참조 전개 연산자 - MDN Iteration protocols - MDN 용도Point 함수 호출 용 / 배열 리터럴 용 / 비구조화용 더 나은 apply 더 강력한 배열 리터럴 구문12345678// 함수 호출 용myFunction(...iterableObj);// 배열 리터럴 용[...iterableObj, 4, 5, 6];// 비구조화(destructuring) 용[a, b, ...iterableObj] = [1, 2, 3, 4, 5]; 더 나은 apply12345678910111213141516function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2];myFunction.apply(null, args);// 이는 다음과 같다.function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2];myFunction(...args);// 이런 식의 사용도 가능하다.function myFunction(v, w, x, y, z) &#123; &#125;var args = [0, 1];myFunction(-1, ...args, 2, ...[3]); 더 강력한 배열 리터럴1234var parts = ['shoulders', 'knees'];var lyrics = ['head', ...parts, 'and', 'toes']; // [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"] new에 적용123var dateFields = readDateFields(database);var d = new Date(...dateFields); 더 나은 push12345678910var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];// arr1에 arr2의 모든 항목을 덧붙임Array.prototype.push.apply(arr1, arr2);// 이는 다음과 같이 치환될 수 있음.var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2); iterable에만 적용12345678var obj = &#123;\"key1\":\"value1\"&#125;;function myFunction(x) &#123; console.log(x); // undefined&#125;myFunction(...obj);var args = [...obj];console.log(args, args.length) //[] 0","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"}]},{"title":"너무 헷갈리는 자바스크립트 Class개념","slug":"so-hard-javascript-class","date":"2016-10-21T01:11:37.000Z","updated":"2016-10-21T03:10:36.000Z","comments":true,"path":"2016/10/21/so-hard-javascript-class/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/21/so-hard-javascript-class/","excerpt":"","text":"자료 출처 자바스크립트 클래스를 정의하는 3가지 방법 자바스크립트 객체 생성 JavaScript 재입문하기 - MDN JavaScript Classes - MDN What is the ‘new’ keyword in JavaScript? - StackOverflow Constructors Considered Mildly Confusing 배경리액트 네이티브를 쓰다가 보면, 자바스크립트 코어를 알아야 문제를 해결해야 하는 경우가 종종 발생한다. 그리고 꼭 리액트 네이티브에서 뿐 아니라 자주 사용하는 언어의 코어를 공부하는 것은 필수적이라고 할 수 있다. 애초에 내가 객체지향 프로그래밍에 대한 이해가 달려서 그런지 내용 자체가 지금은 아리송한 경우가 많은데, 객체 지향 프로그래밍을 따로 공부해야 겠다. 너무 어렵다 멘붕하겠다. 그림으로 그려보자 핵심 자바스크립트에는 클래스가 존재하지 않는다. 클래스를 흉내낼 뿐이다. 의문 함수에서 객체를 생성하기 위한 new 라는 친구도 함수인가?","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"객체지향","slug":"객체지향","permalink":"https://voidsatisfaction.github.io/tags/객체지향/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}]},{"title":"자바스크립트 공부에 도움이 되는 사이트","slug":"good-site-for-javascript-study","date":"2016-10-14T06:56:24.000Z","updated":"2016-10-14T07:11:52.000Z","comments":true,"path":"2016/10/14/good-site-for-javascript-study/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/14/good-site-for-javascript-study/","excerpt":"","text":"JavaScript 입문 Codecademy - Learn JavaScript 아에 자바스크립트를 처음 접한다면 이곳의 튜토리얼을 하는 것을 추천한다. 언어는 영어지만 수준이 높은 영어가 아니라서 알기 쉽다. JavaScript Core Mozilla - JavaScript JavaScript 재입문하기 객체지향 JavaScript 소개 JavaScript classes 한글화가 되어있어서 정말 도움이 많이 되는 사이트 들이다. JavaScript 재입문하기는 내가 막연히 써오던 자바스크립트의 면면을 알기 쉽게 낱낱히 긁어주는 느낌이랄까. 정말 큰 도움이 되었다.","categories":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍/"}],"keywords":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}]},{"title":"React Native의 원리 및 JavaScript의 함수","slug":"javascript-study-and-react-native-function-method","date":"2016-10-14T02:26:21.000Z","updated":"2016-10-14T03:13:25.000Z","comments":true,"path":"2016/10/14/javascript-study-and-react-native-function-method/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/14/javascript-study-and-react-native-function-method/","excerpt":"","text":"출처 및 들어가 보면 좋은 사이트 사부의 말 Intoriduction to JavaScript - Mozilla 재단 객체지향 자바스크립트의 소개 - Mozilla 재단 의문내가 React Native코드를 작성하는 과정에서 다음과 같은 일이 있었다. ListView의 renderRow함수를 this.renderRow로 하고그 안의 TouchableOpacity의 onPress속성에 부모 컴포넌트에서 받아온 함수를 넘겨주려고 했는데,막상 클릭해보니 this.props.함수 == undefined 이라는 것이었다. 즉, this.props에는 그 함수가 존재하지 않는다는 것이었는데, 나는 renderRow라는 함수를 component class안에 정의해두었기 때문에당연히 this가 그 component를 가리킨다고 생각했다. 12345678910111213141516171819202122232425262728293031323334353637383940export default class SchoolBoardList extends Component &#123; static propTypes = &#123; boardItems: PropTypes.array.isRequired, boardItemOnpress: PropTypes.func.isRequired, &#125; constructor(props) &#123; super(props); const ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); this.state = &#123; dataSource: ds.cloneWithRows(this.props.boardItems), &#125;; this.renderRow = this.renderRow.bind(this); &#125; renderRow(rowData) &#123; const &#123; title, date, content, author, good, chat &#125; = rowData; return ( &lt;TouchableOpacity style=&#123;style.item&#125; onPress=&#123;() =&gt; &#123; this.props.boardItemOnpress(); &#125;&#125; &gt; ... &lt;/TouchableOpacity&gt; ); &#125; render() &#123; const &#123; dataSource &#125; = this.state; return ( &lt;View style=&#123;style.container&#125;&gt; &lt;ListView dataSource=&#123;dataSource&#125; renderRow=&#123;this.renderRow&#125; automaticallyAdjustContentInsets=&#123;false&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 이런식으로 되어있는 코드였다. 그래서 어? 어쩐일이지? 하면서 TouchableOpacity내부의 onPress속성 안에 console.log(this)를 넣어보니 웬걸 this는 전역객체를 의미하고 있었다! 그래서 나는 “뭐지? 난 클래스 안에다가 함수를 정의했는데? 왜 this가 전역객체인거야!” 하고 대혼란에 빠졌다. 사부의 답변그래서 나는 바로 사부에게 물어보았다. “왜 클래스 안에다가 함수를 정의했는데 this가 전역이 되는가?” 라고. 그래서 사부는 나에게 “React Native에서 render를 누가 부를까요? 라고 되물었다.” 답은 ‘React Native 엔진’이었다. 사부에 의하면 React Native엔진의 행동은 다음과 같다.(다소 차이점이 있다고는 하지만 지금은 이렇게 알아둬도 된다고 했다.) RN 엔진의 행동 index.js 실행 React Native Lifecycle실행 index.js안의 new component를 만듬 component.render()를 실행해서 view를 만듬 동작 메소드와 함수 클래스.함수 로 실행시키면 클래스 안에 있는 함수를 실행시키는 거여서 메서드 로 처리해요. 근데 형은 보통 this.함수를 클래스 안에서 사용하잖아요 이 경우에는 React Native입장에서 this.함수의 결과가 함수잖아요 그래서 함수로 실행시켜요. 즉 React Native엔진이 component.render()를 실행할때는 this가 component가 되니까 즉 class 가 되니까 render()함수 내에서 사용한 this.함수명 = 메소드(component 클래스 안에서의 함수 ex: 위의 경우 renderRow()와 같은 함수) 이렇게 되는거고 근데 버튼을 클릭하는 행동 같은 경우에는 class안에서 this를 정의해버렸으니 그 this가 전역객체니까 그걸 다시 component로 바꾸기 위해서 constructor나 render안에서 bind(this)하는 것이었다. 즉 그냥 renderRow함수 내에서 &lt;TouchableOpacity onPress={this.props.boardItemOnpress} 이렇게만 하면 RN엔진이 component.renderRow이렇게 실행하지 않기때문에 renderRow안의 this는 전역 객체가 되어 버리고 전역 this에는 this.props.boardItemOnpress가 존재하지 않으니까 this.props.함수 == undefined 이렇게 되었던 것이었다. 그렇기 때문에 이 문제를 해결하기 위해서는 클래스 내부의 constructor함수에서 this.renderRow = this.renderRow.bind(this) 이렇게 this의 지정을 component class로 명확히 해줘야 한다. 이는 함수.bind(this)를 해주기 전까지는 어디에서 혹은 무엇이 그 함수를 부르는가가 중요하지만, 함수.bind(this)를 해주는 행위는 어디에서 그 함수를 호출하든 함수 내부의 this를 지정 해주는 것이다. 느낀 점어떠한 기술을 확실히 ‘내 것’으로 만들기 위해서는 그 기술의 core를 이해하지 않으면 안된다. 이번 일을 계기로 JavaScript의 class개념, 함수 / 메소드 개념 React Native의 Lifecycle같은 개념을 알아야 하는 것의 중요함을 깨닫게 되었다. 자바스크립트에 대해서 깊이 이해하고 싶은 분들은 앞에서 소개한 mozilla재단의 javascript관련 문서를 읽는 것을 추천합니다. 역시 프로그래밍은 재미있다! 그리고 사부는 최고다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"Project Euler 134","slug":"project-euler-134-solution","date":"2016-10-06T16:55:01.000Z","updated":"2016-10-06T17:03:07.000Z","comments":true,"path":"2016/10/07/project-euler-134-solution/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/07/project-euler-134-solution/","excerpt":"","text":"ProblemPrime pair connection Consider the consecutive primes p1 = 19 and p2 = 23. It can be verified that 1219 is the smallest number such that the last digits are formed by p1 whilst also being divisible by p2. In fact, with the exception of p1 = 3 and p2 = 5, for every pair of consecutive primes, p2 &gt; p1, there exist values of n for which the last digits are formed by p1 and n is divisible by p2. Let S be the smallest of these values of n. Find ∑ S for every pair of consecutive primes with 5 ≤ p1 ≤ 1000000. Analysis12345678910111213141516가장 먼저 1부터 10^6+3 까지의 모든 소수의 배열을 구합니다.(10^6까지인 이유는 그래야지 p1이 10^6이하인 모든 소수를 포함할 수 있기 때문입니다.)그 배열에서 p1, p2를 선택해나가며 최소인 n 즉 s를 계산해나갑니다.최소인 n을 계산할때는 p2 * n 의 마지막자리 몇자리수 = p1 이렇게 되어야하는데이는 p1의 1의자리수부터 10의 자리수 100의자리수 ... 이런식으로 거꾸로 구해주면 됩니다.예를들어, p1 = 999979, p2 = 999983라고 하면n 의 1의자리수 = 9 따라서, p2 * i 에서의 i의 1의자리수는 3*3 = 9이므로 3이 되어야합니다.n 의 10의자리수 = 7 따라서, p2 * i 에서의 i의 10의자리수는 3*9 = 27(7 mod 10)이므로 9가 되어야합니다.....위의 행위를 여러번 반복하면 결국 최소인 n을 구할 수 있게됩니다.(그것이 least_n함수)저는 재귀함수를 이용하였습니다.Took 2.37secs Solution123456789101112131415161718192021222324252627282930313233343536373839require 'prime'class Problem134 def self.find_ans primes = primes_until(10**6+3) i = 0; s = 0 while primes[i] &lt; 10**6 p1, p2 = primes[i], primes[i+1] s += least_n(0,p1,p2,0) i += 1 end s end def self.least_n(n,p1,p2,sum) return sum if sum % 10**(p1.to_s.length) === p1 sum_last = (sum / 10**n) % 10 p2_last = p2 % 10 p1_last = (p1 / 10**n) % 10 i = 0 until (p2_last * i + sum_last) % 10 === p1_last i += 1 end sum += p2 * i * 10**n n += 1 least_n(n,p1,p2,sum) end def self.primes_until(n) primes = [] 5.upto(n)&#123; |i| primes.push(i) if i.prime? &#125; primes endendstart = Time.nowp Problem134.find_ansp Time.now - start EfficiencyO(nlogn) Afterthoughts거꾸로 풀어 올라간다는 발상만 할 수 있다면 그렇게 어려운 문제는 아니었던것 같다. 그런데 생각보다 거꾸로 올라가는 알고리즘을 구하는게 쉽지가 않아서 하루정도 쉬고 다시 그 부분만 알고리즘을 짰다. 이번에는 깊이 숙고해서 문제와 모든 정보를 공책에 쓴 뒤에 약간의 손코딩 후에 코드를 작성했는데 정말 큰 도움이 되었다. 역시 파인만 선생님.","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"MECE하게 '생각'하라.","slug":"lesson-from-teacher-with-errors","date":"2016-10-05T16:15:38.000Z","updated":"2016-10-06T04:58:42.000Z","comments":true,"path":"2016/10/06/lesson-from-teacher-with-errors/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/06/lesson-from-teacher-with-errors/","excerpt":"","text":"오늘 사부와의 미팅에서 배운 것들. 에러가 뜨면 막무가내로 실행하지 말고, 한 번 더 논리적으로 천천히 생각해보자. 본질에 입각해서 생각하자. 어떠한 process중에서 에러가 발생하면 그 process의 하나하나의 단계를 MECE(Mutually Exclusive and Collectively Exhaustive)하게 테스트한다. 편한 Tool을 항상 알아보자. ex) Reactotron, Vscode(plug in), Atom eslint, Atom terminal, Zsh 생산성을 상승 시키자. 기회가 있으면 꼭 참여해보자. 오랜만에 사부와 미팅을 했다. 방학동안에 한 번도 보지 못했는데, 여전히 사부는 사부였고, 나 역시 배운 것이 참 많았다. 위에 내가 배운것을 정리해 놓았다. 사고 정지의 위험성파인만 알고리즘, Do not study programming과 같은 글들을 보면 프로그래밍을 잘 하는 방법은 참 간단하고 명쾌하다. ‘손부터 움직이지 말고, 문제를 올바르게 파악하여 해결책에 대하여 숙고한 뒤에 해결하기 위한 코딩을 한다.’ 라는 것이다. 이미 위와같은 글을 몇번이나 읽고 ‘아 프로그래밍을 할 떄는 반드시 이러한 마음가짐으로 해야지’라고 다짐까지 했건만, 정작 내 앞에 ‘익숙하지 않은’문제들이 다가오면 불쑥 손부터 움직이기 시작한다. 아마 초보 코더의 본능과 같은 것일까? 이번 웹뷰 에러를 디버그 하는 상황에서도 아무런 논리적 근거도 없이 나는 ‘이걸 이렇게 변경하면 되겠지’라는 마음가짐으로 일단 iphone의 simulator를 실행시키려고 했다. 그 때 사부가 잠깐만요! 좀더 천천히 생각해봐요 하는 말에 ‘아 그렇구나 너무 조급했구나’ 싶었다. 그리고 논리적으로 따져나가니 결국에는 거짓말같이 전혀 단서가 없어보이는 문제가 해결되었다. 이렇게 문제가 해결되는 것을 보며 나는 몇해전 학교 세미나에서 교수님이 하신 말씀이 생각났다. 사고 정지야 말로 가장 위험한 것이다. 아무런 생각없이, 아무런 논리적 근거없이 일을 행하는 것은 위험하다는 말씀이었다. 이 말씀을 생각하니 또 세미나에서 교수님이 하신 다른 말씀이 생각났다. 아무리 복잡해보이는 일이라도 하나하나 MECE(빠짐없이, 중복없이)하게 행한다면 논리적인 문제는 반드시 특정할 수 있다. 어찌보면 당연한 말이고 나 역시 말을 들을때 마다 고개를 끄덕였던 기억이 있지만 이번에는 언제 그 말을 들었냐는 듯이 망각해버리고 말았다. 사실 이번 뿐 아니라, 다소 어려운 Euler Project문제를 풀 떄도 항상 잊어버리고 만다. 앞으로는 사고정지가 일어날 때 마다 MECE를 떠올려야겠다. 프로그래밍의 신비이번에 내가 사고정지에 대한 글을 쓰면서 생각난 프로그래밍의 재미있는 특징은, 프로그래밍에서 나오는 문제는 대부분 ‘끊임없이 생각하는 한 반드시 풀린다’는 점이다. 프로그래밍이 각종 작은 도구들을 조합해서 큰 물건을 만드는 것이기 때문에, 작은 도구들을 논리적으로 이리저리 조합하다 보면 반드시 해답이 나온다는 것이다. 하지만 해답을 찾는 과정을 위에 언급했듯이 문제를 올바르게 파악하여 해결책에 대하여 숙고한다면 더더욱 정확하고 빠르게, 그리고 간결하게 해답을 찾을 수 있을 것이다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Project Euler 131","slug":"project-euler-131","date":"2016-10-04T12:21:39.000Z","updated":"2016-10-04T12:32:42.000Z","comments":true,"path":"2016/10/04/project-euler-131/","link":"","permalink":"https://voidsatisfaction.github.io/2016/10/04/project-euler-131/","excerpt":"","text":"ProblemPrime cube partnership There are some prime values, p, for which there exists a positive integer, n, such that the expression n3 + n2p is a perfect cube. For example, when p = 19, 83 + 82×19 = 123. What is perhaps most surprising is that for each prime with this property the value of n is unique, and there are only four such primes below one-hundred. How many primes below one million have this remarkable property? Analysis let n^3 + n^2p = (n+k)^3 make it simple, n^2p = 3kn^2 + 3k^2n + k**3 if n &lt;= k, as n, p, k is all integers, k = nl n^2p = 3ln^3 + 3l^2n^3 + l^3n^3 p = nl(3 + 3l + l^2) as p is a prime n and l should be a 1 n = k = 1 p = 7 if n &gt; k, n = kl k^2l^2p = 3k(kl)^2 + 3k^2(kl) + k^3 l^2p = 3kl^2 + 3kl + k Therefore, p = 3k + 3k/l + k/l^2 as p is a prime, k = al^2, p = 3al^2 + 3al + a = a(3l^2 + 3l + 1) so, a = 1 p = 3l^2 + 3l + 1 Based on this fact, we can find all primes satisfing 3l^2 +3l + 1 under one million including p = 7 Took 0.004sec Solution12345678910111213141516171819require 'prime'class Problem131 def self.find_ans i = 1; cache = [] loop do value = 3*i**2 + i*3 + 1 break if value &gt; 10**6 cache.push(value) if value.prime? i += 1 end cache.length endendstart = Time.nowp Problem131.find_ansp Time.now - start EfficiencyO(n) AfterthoughtsOther solution. from umu What a beautiful nice little problem. Same as most of you, I guess. If n=ap, then n³+n²p=(a³+a²)p³, then a³+a² must be a cube, what is impossible, as next cube after a³ is a³+3a²+3a+1. So n and p are coprime, so are n² and n+p. So if n³+n²p=n²(n+p) is a cube, so n² and n+p are cubes, so n and n+p are cubes. (n+a)³-n³=3a+3a²+a³ is never prime for a&gt;1. So n and n+p are consecutive cubes. So it’s enough to check all differences between consecutive cubes for being prime. 정수론은 어렵지만 다가기는 생각보다 쉽고 흥미롭다.","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"Project Euler 123","slug":"project-euler-123","date":"2016-09-30T03:54:33.000Z","updated":"2016-09-30T04:15:12.000Z","comments":true,"path":"2016/09/30/project-euler-123/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/30/project-euler-123/","excerpt":"","text":"ProblemPrime square remaindersProblem 123 Let pn be the nth prime: 2, 3, 5, 7, 11, …, and let r be the remainder when (pn−1)n + (pn+1)n is divided by pn2. For example, when n = 3, p3 = 5, and 43 + 63 = 280 ≡ 5 mod 25. The least value of n for which the remainder first exceeds 109 is 7037. Find the least value of n for which the remainder first exceeds 1010. Analysisn is the n term of prime. if so,remainder = (Pn-1)^n + (Pn+1)^n === nPn({1+[-1]^(n-1)} + {1 + [-1]^(n)}) (mod Pn^2) In this situation, n should be odd since the remainder is 2 if n is even. Therefore, remainder is 2nPn (n is odd) Based on this fact, we can get first nth prime that exceeds 10^10 by using bruteforce. Efficiency O(n^(3/2))Took 1.8sec Solution1234567891011121314151617181920212223242526class Problem123 def self.find_ans limit = 10**10 ; i = 3 ; n = 1 loop do if prime?(i) if n % 2 === 1 n += 1 else n += 1 value = 2*n*i return n if value &gt; limit end end i += 2 end end def self.prime?(n) 2.upto(Math.sqrt(n))&#123; |i| return false if n % i === 0 &#125; return true endendstart = Time.nowp Problem123.find_ansp Time.now - start EfficiencyO(n^(3/2)) Afterthoughtshk’s solution on forum was quite interesting. he used the fact that the number of primes less than n tends to n/ln(n) then, n can be substituted by n/ln(n).thus, remainder could be substituted by 2*Pn^2/ln(n) Of course, according to Prime number theorem - Wikipedia, pi(n) is almost equal to(~) n/ln(n). the asymptotic notation meaning, again, that the relative error of this approximation approaches 0 as n increases without bound.","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"Project Euler 124","slug":"projecteuler124","date":"2016-09-29T14:40:35.000Z","updated":"2016-09-29T14:57:42.000Z","comments":true,"path":"2016/09/29/projecteuler124/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/29/projecteuler124/","excerpt":"","text":"ProblemOrdered radicalsProblem 124 problem is here Solution bruteforce dictionary You can define rad function by using prime_division method. And from 1 to 100000, you can get each of rad value. If a number’s rad is not included in cache, create new array of the rad value set.If it is included, just add on the rad value set After that, you can easily get E(10000) 1234567891011121314151617181920212223require 'prime'class Problem124 def self.find_ans cache = &#123;&#125; 1.upto(10**5) do |i| rad = rad(i).to_s cache.has_key?(rad) ? cache[rad].push(i) : cache[rad] = [i] end cache.values.flatten[9999] end def self.rad(n) value = 1 Prime.prime_division(n).each&#123; |e| value *= e.first &#125; value endendstart = Time.nowp Problem124.find_ansp Time.now - start EfficiencyO(n^(3/2))","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"파인만 알고리즘","slug":"feynman-algoritm","date":"2016-09-29T04:48:51.000Z","updated":"2016-09-29T05:29:04.000Z","comments":true,"path":"2016/09/29/feynman-algoritm/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/29/feynman-algoritm/","excerpt":"","text":"출처[과학의 창]내부와 외부, 그리고 경계 - 조선일보 파인만 알고리즘(알고리즘 문제풀이) 해결하려는 문제를 종이에 쓴다.(문제의 이해) 정말 골똘히 그 해결책을 생각한다.(알고리즘의 설계) 답을 쓴다.(코딩) 내용###[과학의 창] 내부와 외부, 그리고 경계 김범준 성균관대 물리학과 교수 | 2016/09/28 03:05 물리학자 파인만이 이용했다고 일컬어지는 일반적인 문제 해결 알고리듬이 있다. 숙지하면 이 방법으로 풀지 못할 문제가 없다. 독자들도 귀를 열고 주의 깊게 들어보시길. 파인만 알고리듬은 다음의 세 단계로 이루어진다. 첫째, 해결하려는 문제를 종이에 쓴다. 둘째, 정말 골똘히 그 해결책을 생각한다. 셋째, 답을 쓴다. 정말 쉽지 않은가. 처음 내가 이 이야기를 들었을 때는 그냥 농담인 줄 알았다. ‘파인만씨, 농담도 잘하시네!’라는 책 제목에서도 알 수 있듯 파인만은 물리뿐 아니라 농담도 정말 잘했던 사람이다.(참고로 물리학자들은 “물리학을 연구한다”고 하지 않고, 보통 “물리를 한다”고 말한다. 파인만은 물리 하는 사람이면 누구나 다 인정하는, 정말 물리를 잘했던 사람이다.) 나도 물리를 하며 살아온 세월이 좀 늘다 보니, 파인만 알고리듬에 대해 더 이해할 수 있게 되었다. 많은 독자가 이 해결 알고리듬의 가장 중요한 단계가 문제의 해결책을 고민하는 둘째 단계라고 짐작하겠지만, 그렇지 않다. 사실 가장 중요한 것은 문제를 종이에 쓰는 첫 단계다. 왜 그럴까. 문제를 풀 때, 가장 중요한 단계는 바로 문제가 뭔지를 아는 거다. 문제가 무엇인지를 알 때에만 문제를 종이에 적을 수 있다. 혹은, 문제를 종이 위에 적으려 노력하는 단계를 거쳐야만 문제가 명확해지기도 한다. 스스로 종이에 적지 못할 문제는 결코 해결할 수도 없다. 물리학자가 연구할 때도 마찬가지여서, 가장 중요한 단계가 바로 문제가 뭔지를 아는 거다. 문제가 무엇인지 파악할 때, 물리학자가 처음 거쳐야 하는 사고의 첫 관문이 있다. 오늘 할 얘기가 바로 이 부분이다. 물리학자는 문제를 종이에 적는 파인만 알고리듬 첫 단계의 맨 앞에서 먼저 ‘경계’를 설정한다. 안과 밖의 경계다. 무슨 얘길까. 공기 중에서 떨어지는 돌멩이의 운동을 이해하고자 하는 물리학자가 있다. 이 학자가 처음 하는 일은 이 물체의 운동을 이해하기 위한 사고의 체계 안에 도대체 무엇 무엇을 집어넣을까 하는 고민이다. 딱 돌멩이 하나만을 문제의 내부에 넣고, 돌멩이를 제외한 우주의 모든 것을 외부로 해서 둘 사이의 경계를 설정한다면 어떨까. 이 경우 돌멩이를 아래로 당기는 것이 내부에 없으니 돌멩이는 떨어질 수가 없고, 따라서 문제를 이렇게 적었다면 잘못 적은 거다. 당연히 문제의 내부에 다른 것을 더 넣어야 한다. 바로 돌멩이를 아래로 잡아끄는 지구의 중력이다. 자, 이제 돌멩이와 지구의 중력만을 문제의 내부(이 내부를 물리학자는 계(系), 혹은 시스템이라 부른다)로 생각해 이 둘과 우주의 나머지 모든 것 사이에 안과 밖의 경계를 설정하면 어떨까. 이 경우 돌멩이는 아래로 떨어지지만, 공기는 여전히 경계의 밖에 있으니 돌멩이는 공기에 의한 저항력을 느끼지 못한다. 공기의 효과까지 넣으려면 이제 경계는 조금 더 확장된다. 문제가 복잡할수록, 문제를 정확히 기술하기 위해 노력할수록, 내부와 외부를 나누는 경계는 시스템의 밖을 향해 확장된다. 확장된 경계로 둘러싸인 큰 시스템에서 문제의 해결은 점점 더 어려워지지만, 어려운 것이 두려워 우주 전체에서 너무 작게 시스템을 도려낸다면 말도 안 되는 엉뚱한 결과를 얻게 된다. 마치 아래로 떨어지지 않는 돌멩이처럼. 우리가 살아가는 사회에서 벌어지는 문제는, 아래로 떨어지는 돌멩이에 비하면 정말 복잡하다. 복잡한 현실의 문제를 이해하려면 내부와 외부 사이의 경계를 현명하게 설정하는 것이 필요하다. 경계가 분명하지 않을 때는 내부를 크게 설정하는 것이, 중요한 무엇을 외부로 배제해 잘못된 해결책을 찾는 것보다는 훨씬 더 바람직하다. 우리나라에서 벌어지는 일이라면 우리 모두는 내부라 할 수 있다. 우리 안에 외부는 없다. 다른 좋은 글Feynman Algorithm(파인만 알고리즘) - 잡생각 전문 블로그","categories":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}],"tags":[{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://voidsatisfaction.github.io/tags/알고리즘/"}],"keywords":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}]},{"title":"불교와 프로그래밍","slug":"buddhism-and-programming","date":"2016-09-29T02:08:18.000Z","updated":"2016-09-29T05:37:55.000Z","comments":true,"path":"2016/09/29/buddhism-and-programming/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/29/buddhism-and-programming/","excerpt":"","text":"법륜스님의 즉문즉설나는 요즈음 학교 도서관에 갈 때 팟캐스트 ‘법륜 스님의 즉문즉설’을 즐겨 듣는다. ‘법륜스님의 즉문즉설’은 법륜스님이 한국과 세계의 이곳저곳을 돌아다니시면서 강연하시는 내용이다. 여기서 특이한 점은, 스님이 일방적으로 자신의 생각과 견해를 전하는 것이 아니라는 점이다. 항상 스님은 질문자의 질문을 먼저 듣고 그것에 대한 답변을 하신다. 질문의 내용을 조금 발췌해보자면 다음과 같다. 부모님과의 사이가 좋지 않다. 어떻게 해야하는가? 아이가 공부를 안하는데 어떻게 하면 좋을까? 내가 화를 잘 참지 못한다. 어떻게 해야하는가? 시어머니와의 사이가 좋지 않은데 어떻게 해야하는가? 이 세상은 올바르게 사는 사람이 더 손해보는 것 같다. 나는 어떻게 살아야 하는가? 에피소드 하나 하나가 5~20분 사이로 생각보다 길지도 않고 정말 나도 한 번쯤은 생각해봤을 그런 문제들이며 현실과 동떨어지지 않은것 같아서 내용이 공감도 되고 참 재미있다. 하지만 즉문즉설의 백미는 역시 법륜스님의 명쾌한 대답이다. 즉문즉설을 관통하는 세가지 사고방식스님의 즉설을 듣고 있으면 언제나 세가지 원칙이 있다는 것을 느낀다. 모든 문제는 ‘나’에게 있다. 따라서 문제의 해결의 열쇠 역시 ‘나’에게 있다. 나는 나고 너는 너. 내 마음대로 타인을 변화시키려 하지마라. 기대하지 마라. 모든 문제는 ‘나’에게 있다.즉문즉설에서 질문자는 간혹 ‘~때문에 화가나거나 힘들다. 그렇다면 어떻게 그를 고쳐야 하는가?’ 와 같은 질문을 할 때가 있다. 그럴때 스님은 항상 모든 문제의 핵심은 바로 나 자신에게 있다고 말씀하신다. 그러므로 내가 어떠한 마음가짐을 가지느냐에 따라 문제를 해결할 수 있다고 하신다. 예를 들어, 남편이 매일 술을 마시고 들어와 화가났을 경우, 스님은 다음과 같이 조언하신다. ‘매일아침 하루 빠짐없이 매일 우리 남편 술을 꼭 먹고 들어오게 해주십시오’를 생각하며 108배를 하시죠. 그리고 오히려 술을 마시고 오지 않을 경우는 술을 준비해서 그 기도를 이루도록 해야합니다. 여기서 포인트는 마음에서 우러나와서 그렇게 해야 한다는 것이다. 그러면 3년 정도 후에는 남편의 술주정이 줄어들고 거짓말 같이 술을 마시지 않게 된다는 것이며, 자기자신의 생활이 술에 대한 스트레스가 사라짐과 동시에 보다 편해진다는 것이다. 나는 이 조언이 스님이 이야기하고자 하는 삶의 지혜를 고스란히 보여주고 있다고 생각한다. 그 지혜 중 하나는, 스트레스의 원인을 자기자신의 마음 으로 지목하신 것이다. 질문자는 남편이 술을 마시는 행위를 자기자신을 스트레스 받게하는 요소로 생각하고 있다. 하지만 스님은 술을 마시는 행위를 스트레스의 요소가 아닌, 긍정적인 요소 로 발상의 전환을 제안한다. 이것이 사고의 역전이자 즉문즉설의 백미. 나는 나고 너는 너. 내 마음대로 타인을 변화시키려 하지마라.또한 스님의 말씀에는 또 다른 지혜의 아름다움이 숨겨져 있는데 그것은 다름아닌 타인의 문제와 나와의 분리 다. 질문자는 분명 남편을 변화시킬 방법을 스님에게 묻고싶었겠지만, 스님은 ‘술을 마시는 일’자체를 내가 원하는대로 변화시키는 것은 욕심이라고 하신다. 사실 우리의 삶에서 타인의 행동을 긍정적인 방향이든 부정적인 방향이든 변화시키는 것은 정말 쉽지 않은 일이다. 내가 아무리 노력해도 그 사람은 내 노력을 티끌로도 보지 않는 경우도 심심치 않게 볼 수 있다. 따라서 만일 내가 타인을 변화시키는 것이 나의 과제이자 숙명으로 여기면 그 짐으로 인한 무게가 내 삶 자체를 짓누를 것이다. 그래서 스님은 애초에 타인의 짐을 자신이 짊어질 필요가 없다 고 역설하신 것이라고 생각한다. 이와 같은 마음가짐은 타인은 타인이 그러한 행동을 하는 자유가 있다는 것을 존중하는 동시에 나 자신의 짐도 덜어버리는 것이다. 기대하지 마라.마지막으로 스님은 ‘기대하지 말라’고 충고하신다. 대개 사람들은 기도를 하면서 자신을 둘러싼 환경이 변화가 되길 기대한다. 하지만, 기대를 하므로써 우리는 ‘기대’라는 이름의 새로운 짐을 짊어지게 되는 것이다. 만일 내 기대가 이루어지지 않는다면 그 기대라는 짐은 또다시 무거운 고뇌가 되어 나의 어깨를 누를것이다. 그래서 스님은 무주상보시(無住相布施). 즉, 어떠한 행위의 결과에서 아무런 기대를 하지 않는 마음의 중요성을 강조하신다. 중요한 것은 그 행위를 하는 것이지 행위의 결과는 자신의 마음과 아무 상관이 없다는 것이다. 프로그래밍과 불교법륜스님의 위의 세가지 원칙과 더 나아가 불교의 가르침은 프로그래밍의 세상과 일맥상통하는 부분이 있다. 다음과 같이 생각해보자. 가장 먼저, ‘나’는 나를 둘러싼 세상의 환경적 요소를 인수로서 받는 함수라고 생각한다. 그리고 그 함수 내부에는 내가 세상을 바라보는 시선 즉. 세상을 바라보는 알고리즘이 들어있는것이다. 이를 코드화한다면 다음과 같을 것이다. 1234567function me (나를 둘러싼 환경인수들)&#123; 내가 어떻게 환경을 바라보는가? 내가 어떻게 환경을 활용하는가?&#125;me(환경인수들) // 이것이 내가 세상에 살아가는 output. 내가 세상을 살아가는 모습 우리들은 보통 나를 둘러싼 환경인수들을 탓하며 무리하게 환경을 바꾸려고 한다. 하지만 법륜스님을 비롯한 불교의 가르침은 내가 제어할 수 없는 환경 인수에 초점을 맞추는 것이 아닌, 내가 어떻게 환경을 바라보는가? 내가 어떻게 나에게 주어진 환경을 활용하는가? 와 같은 ‘나’의 마음에 좋은 알고리즘을 만드려는 구상에 초점을 맞춘다. 사실 프로그래밍에서도 그렇듯이 함수의 output을 환경인수를 간단히 변경하는게 언뜻 보면 쉬울 것 같아보인다. 하지만 또 우리가 평소 생활하면서 느끼듯이 타인을 내가 원하는 방향으로 변화시키는 것은 쉽지 않다. 또한, 타인을 변화시켰을때는 반드시 부작용이 따른다. 하지만 그에 반하여, 잘 정의된 함수는 인수에 object가 오든, string이 오든 어떠한 자료구조, 어떠한 데이터 형태가 input으로 들어와도 원하는 output으로 변화시킬 수 있다. 따라서 우리는 어떠한 일이 내가 바라는 바 처럼 되길 바라고 기도하는 것이 아니라,어떠한 일이 닥치더라도 흔들리지 않는 그런 마음을 갖게 될 수 있도록 기도해야한다. 나는 어떠한 input이 오든 흔들리지 않고 나만의 신념을 지킬 수 있는 output을 낼 수 있는 그런 하나의 함수가 되고 싶다. 그래서 이제 나는 나에게 묻고자 한다. ‘나는 어떤 함수인가?’ ‘나의 함수는 환경인수를 제어하려 하는가, 아니면 내 마음의 좋은 알고리즘을 만드려하는가?’ 나는 종교를 믿지 않지만 어느종교이든 아름다운 말과 생각에는 그 특유의 향기가 있는 것을 느낀다. 마치, 절차지향적, 객체지향, 함수형, 선언형 프로그래밍 등등.. 각각의 프로그래밍 스타일이 고유의 매력을 뽑내는 것과 같이. 또한 각각의 프로그래밍 스타일도 궁극적으로 ‘좋은 프로그램을 작성한다.’ 라는 공통된 궁극적인 지향점 있듯이, 모든 종교도 ‘향기롭고 아름다운 삶을 산다’ 라는 공통의 궁극적인 지향점 있다고 생각한다. 이렇게 잘 생각해보면 세상을 살아가는 이치가 프로그래밍에도 곳곳에 스며들어있는 것이 아닌가 싶다. 작지만 나의 배움을 바탕으로 세상을 이런식으로 나만의 방식으로 의미부여를 해가는것은 참 재밌다. 같은 세상이라도 나에게는 조금 더 특별해 보이니까. 항상 좋은 말씀 감사합니다 법륜스님. 참고 법륜스님의 즉문즉설 팟캐스트","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"},{"name":"프로그래밍","slug":"프로그래밍","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍/"},{"name":"불교","slug":"불교","permalink":"https://voidsatisfaction.github.io/tags/불교/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"React Native 공부기 ~ Redux 후편","slug":"redux-study2","date":"2016-09-27T08:37:59.000Z","updated":"2016-09-27T10:25:38.000Z","comments":true,"path":"2016/09/27/redux-study2/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/27/redux-study2/","excerpt":"","text":"지난번에 공부한 것들 props의 공급원 dispatch(action.login(sessionID))의 의미 Redux의 매커니즘 다시 이야기로 돌아와서 저런식으로 redux에 state을 저장해서 다른 컴포넌트들이 그걸 참조하는거에요. Q) 그럼 dumbcomponent에서 데이터가변화 =&gt; screen으로 데이터가 감 =&gt; action생성 =&gt; dispather에 의한 redux상의 데이터변화(reducer) 요로코롬 이해하면 될까? 네. 아 이제 완벽히 이해된다. connect가 뭔지도 아시겟죠? 다른 일반적인 react-redux아키텍쳐랑 조금 달라서 아마 어려울수도 있었을거에요. dumbcomponent에서 데이터가변화 =&gt; screen으로 데이터가 감 =&gt; action생성 =&gt; dispather에 의한 redux상의 데이터변화(reducer) 이게 아니라, dumbcomponent에서 데이터가변화 =&gt; action생성 =&gt; dispather에 의한 redux상의 데이터변화(reducer) 이거여서. 보통은 react의 state을 아에 쓰지 않거든요. web front 의 경우에는 그냥 전부다 redux로 처리하니까 textInput 같은것도 redux state를 바꾸는걸로 해요. 근데 저희는 redux state을 핸드폰에다가 저장을 해놔서 그렇게 자잘한걸 전부다 redux로 처리를 하면 퍼포먼스가 나빠질 것 같아서, 적절히 나눈거구요. 대충 redux 에 대해 이해가 되셧나요? Q) redux로 처리하는것과 react자체 state로 처리하는 것의 차이는 뭐야? redux로 처리는 action, dispatch을 이용해서 redux의 state를 바꿔서 view을 바꾸는 거구요. react 자체 state는 this.setState을 통해서 view를 바꾸는 거죠. 그리고 사실 redux로 처리를 하면 action -&gt; middleware -&gt; reducer의 형태로 redux state가 변경되는데, 이 과정에서 여러가지를 할수가 있어요 반면에 setState는 setState 만으로 값을 바꾸는 거여서 복잡한 처리에는 좋지 않아요. 그렇지 middleware에서 데이터를 가공하든 다른곳에 통신을 하던 할 수 있으니까 redux는 Q) 근데 내 짧은 생각으로는 아무래도 redux가 여러가지 모듈을 거치니까 더 느릴거 같다는 생각이드는데.. redux가 더 느릴걸요. 더 느린데 할수있는게 많은거죠. 자유도 라고 해야하나요. 일단은 액션만 생성하면 redux의 정보를 변경할 수 있어요. this.props.lecture는 어디에서 오는가?아 그 props 가 어디서 오는지 설명해 드릴게요. 12345678910111213screen/LectureDetailScreenexport default connect( (state) =&gt; (&#123; timeTable: state.timeTable, &#125;), () =&gt; (&#123;&#125;), (stateProps, dispatchProps, ownProps) =&gt; (&#123; ...dispatchProps, ...ownProps, lecture: stateProps.timeTable[ownProps.day][ownProps.time], &#125;))(class LectureDetailScreen extends Component &#123; this.props.timeTable에 state.timeTable을 연결시켜요 또한, connect의 3번째 인수는 123456(stateProps, dispatchProps, ownProps) =&gt; (&#123; ...dispatchProps, ...ownProps, lecture: stateProps.timeTable[ownProps.day][ownProps.time], &#125;) 이런 함수인데 여기서 state.Props는 저기 위에 있는 { timeTable: state.timeTable }가 들어가 있어요. 그리고 ownProps는 원래 얘가 가지고 있는 props을 의미해요. lectureDetail은 timeTableScreen 에서 오는 얘인데 그때 Action.lectureDetail({ day, time})으로 보냈으니 this.props.day, this.props.time 을 받게 되죠 ownProps.day과 ownProps.time 은 timeTable에서 받은 day와 time 이에요 우리가 lectureDetail에서 필요한건 timeTable이 아니라 특정 timeTable안에 있는 특정 lecture 이기 때문에, lecture: stateProps.timeTable[ownProps.day][ownProps.time], 이걸 써서 this.props.lecture에 lecture을 주는거에요. 그래서 우리는 컴포넌트 안에서 this.props.lecture 만으로 얘의 lecture을 알수가 있죠. 사실 그냥 this.props.lecture = this.props.timeTable[this.props.day][this.props.time] 와 같이 해도 되는데 저건 별로 좋지도 않고 데이터 가공이랑 데이터 사용을 분리해서 적어놔야 보기가 편해요. “아 이 컴포넌트는 lecture을 쓰는구나 timeTable 전체를 안쓰는군.” 이렇게요. 123456789101112131415161718192021screen/scheduleScreenexport default connect((state) =&gt; &#123; const timetableScheduleItems = state.timeTable ? state.timeTable.reduce((sum, dayTimetable) =&gt; &#123; const dayTimetableSchedules = dayTimetable.reduce((daySum, lecture) =&gt; &#123; const timelines = lecture.timelines.map((timeline) =&gt; (&#123; ...timeline.info, lectureName: lecture.lectureDPName, &#125;)); return [...daySum, ...timelines]; &#125;, []); return [...sum, ...dayTimetableSchedules]; &#125;, []) : []; const scheduleItems = [ ...timetableScheduleItems, ...state.schedules, ]; return (&#123; scheduleItems, &#125;);&#125;)(class ScheduleScreen extends Component &#123; 이건 scheduleScreen 인데 얘도 timeTable을 가공해서 shceduleItem을 만드는거에요.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"https://voidsatisfaction.github.io/tags/Redux/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"React Native 공부기 ~ Redux 전편","slug":"redux-study1","date":"2016-09-27T05:17:03.000Z","updated":"2016-09-27T08:39:38.000Z","comments":true,"path":"2016/09/27/redux-study1/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/27/redux-study1/","excerpt":"","text":"나의 질문 123456_showAddLectureRatingScreen() &#123; const &#123; lecture &#125; = this.props; Actions.lectureRatingAdd(&#123; lecture, &#125;);&#125; 여기서 lecture를 this.props에서 가져오는데 그 props는 어디에서 오는지가 궁금해 사부의 답변props를 가져오는 곳이 3개가 있어요. 부모 Component가 주는 경우 Redux가 주는 경우 react-native-router-flux 라이브러리를 사용하는데 그때 화면전환을 할때 Action 을 이용하는데 그 화면전환을 할때 주는경우 그렇다면 const { lecture } = this.props; 이건 어디서 가져왔을까요? 그걸 알려면 일단 얘가 screen 컴포넌트인지 자식 컴포넌트인지를 봅니다. 왜냐면 자식컴포넌트는 무조건 부모 component에게만 props을 받고 redux나 router을 사용하지 않기로 했기 때문이죠 Component가 screen일 경우부모 component가 없기때문에 redux나 router 입니다근데 redux의 경우에는 12345678910LectureTimelineScreen과 reduxexport default connect( (state) =&gt; (&#123; user: state.userInfo, &#125;))(class LectureTimelineScreen extends Component &#123; ...&#125; 보통 screen은 일반 자식 컴포넌트와 다르게 connect라는 걸로 component을 감싸는데 저 connect가 redux와 연결하는 고리 같은거에요. 저렇게 하면 component에서 this.props.user가 생겨요.그리고 그 this.props.user는 현재 redux의 state의 userInfo가 들어가게 되는거죠그래서 맨위를 보면 redux에서 받는 props을 알수 있어요 userInfo는 Reducer에 있는 userInfo.js 얘가 되는거구요 1234567timeTableScreen과 reduxexport default connect((state) =&gt; (&#123; timeTable: state.timeTable, timeTableSetting: state.setting.timeTableSetting,&#125;))(class timeTableScreen extends Component &#123; timeTableScreen은 timeTable.js reducer와 setting.js reducer를 참조해서 가져오게 됩니다. 그렇다면 위에 redux에서 정의되지 않는 props는 router에 의해서 가져오는 props라고 생각할 수 있죠. 그렇다면 lectureDetail에서 가지고 있는 this.props.lecture는 12345678910timeTableScreen의 _clickLecture함수_clickLecture(time, day, lectureCode) &#123; Actions.lectureDetail(&#123; time, day, lectureCode, &#125;);&#125; timeTableScreen을 보면 저걸로 인해서 어디를 클릭했는지를 알수가 있어요. 월요일 1겐 이면 day: 0 time: 0이 this.props 에 들어가게 되겠죠. 저렇게 해서 화면끼리 데이터를 교환할수 있어요. 12345678910111213LectureDetail과 reduxexport default connect( (state) =&gt; (&#123; timeTable: state.timeTable, &#125;), () =&gt; (&#123;&#125;), (stateProps, dispatchProps, ownProps) =&gt; (&#123; ...dispatchProps, ...ownProps, lecture: stateProps.timeTable[ownProps.day][ownProps.time], &#125;))(class LectureDetailScreen extends Component &#123; 일단 맨끝만 보면 this.props.lecture에 stateProps.timeTable[ownProps.day][ownProps.time], 가 들어간다는걸 알수가 있어요 lecture는 저기에서 오는거에요 그리고 this.props.timeTable 에는 state.timeTable 이 들어가겟죠 여기까지는 이해가 되시나요? 더 깊이 나아가서Q) 흠 철아 근데 redux의 state는 schema같이 형태만 정해져있는거야 아니면 정보가 저장되어있는거야? 정보가 저장되어 있어요.형태만 있는게 처음 상태에요 그리고 우리가 dispatch(action.xxxxxx) 이런식으로 쓰는 코드가 있잖아요.그 action이 reducer 에 있는 안에 있는 코드를 불러내요.그러면 그에 알맞게 state가 바뀌게 되는거죠. 가장 쉬운걸로는 1234567891011121314151617181920212223 reducers/session.js export default function reducer(state = initialState, action = &#123;&#125;) &#123; switch (action.type) &#123; // focus action is dispatched when a new screen comes into focus case LOG_IN : return &#123; ...state, sessionID: action.sessionID, logged: true, &#125;; case LOG_OUT : return &#123; ...state, sessionID: '', logged: false, &#125;; default: return state; &#125;&#125; 이렇게 되어 있잖아요 LoginScreen 보면 로그인 성공하면 dispatch(action.login(sessionID)); 이런코드를 불러요 응응 저기 있는 login은 123456789101112131415161718192021action/session.jsexport const LOG_IN = 'LOG_IN';export const LOG_OUT = 'LOG_OUT';import &#123; setSession &#125; from '../api/base';/* * 액션 생산자 */function login(sessionID) &#123; setSession(sessionID); return &#123; type: LOG_IN, sessionID &#125;;&#125;function logout() &#123; setSession(''); return &#123; type: LOG_OUT &#125;;&#125;export default &#123; login, logout &#125;; 여기 있는데 흐음 일단 setSession은 예외이니 그거 말고 login하면 return이 return { type: LOG_IN, sessionID }; 이거죠 Q) dispatch(action.login(sessionID));이 코드에서 session.js를 참조하라고 어디에 나와있어? action이 import action from &#39;../../actions&#39; 이런 코드 위에 있죠 그러면 action/index.js 을 참조하겟죠? 우리 컴포넌트들도 그냥 폴더까지만 참조하게하면 자동으로 index.js 을 참조하니까요 그래서 action/index.js을 보면 얘가 session을 참조해요 … 이게 참조표신가 보네 참조보다는 import가 맞겠죠. 그러면 return { type: LOG_IN, sessionID }; 얘가 return 되고 그걸 dispatch가 reducer로 보내요. 그러면 또 reducer/index.js을 보고 지금 type: LOG_IN 이죠 type: LOG_IN 1234567891011121314151617181920212223reducer/session.js export default function reducer(state = initialState, action = &#123;&#125;) &#123; switch (action.type) &#123; // focus action is dispatched when a new screen comes into focus case LOG_IN : return &#123; ...state, sessionID: action.sessionID, logged: true, &#125;; case LOG_OUT : return &#123; ...state, sessionID: '', logged: false, &#125;; default: return state; &#125;&#125; 그러면 action.type이 LOG_IN이 코드가 실행이 되고 Q) 아 그럼 index.js안에 사실상 모든 reducer type가 들어가있는거나 마찬가진데 알기 쉽게 나눈거 뿐이구먼 저거 하나하나 import 하면 귀찮아 지니깐 바로 reducer 까지만 import 하도록 한거에요. action도 마찬가지고요. 123456return &#123; ...state, sessionID: action.sessionID, logged: true,&#125;; 여기서 return값이 새로운 state.session 값으로 바뀌어요 12345const initialState = &#123; sessionID: '', logged: false,&#125;; 이게 초기치. 그래서 sessionID가 생기고 logged가 true가 되죠. 마찬가지로 reducer/schedule.js 을 보면 12345678910111213141516171819202122reducer/schedule.jsswitch (action.type) &#123; // focus action is dispatched when a new screen comes into focus case ADD_SCHEDULE : return [...state, action.newScheduleItem]; case EDIT_SCHEDULE : return [ ...state.slice(0, action.index), action.scheduleItem, ...state.slice(action.index + 1), ]; case DELETE_SCHEDULE : return [ ...state.slice(0, action.index), ...state.slice(action.index + 1), ]; default: return state; &#125; 스케쥴 추가면 뒤에 새로운 아이템을 붙이고 edit면 그 아이템만 교체 delete면 그거만 제거 아하 알겠어. 매우매우 알기 쉬운 설명이구만! 아 드디어 리덕스의 매커니즘을 이해했어 ㅠㅠ. 데이터변경을 위한 흐름을 파악하면 되는거네. 이런식으로 되어있다보니 아무래도 전에 봤던 그림이 어려워보였던 것 같아. the upper picture is from http://www.slideshare.net/nikgraf/react-redux-introduction 이제는 이 그림도 이해할 수 있게 되었어! 리덕스의 매커니즘 dumbcomponent에서 데이터가변화 =&gt; screen으로 데이터가 감 =&gt; action생성 =&gt; dispather에 의한 redux상의 데이터변화(reducer) 2편에서 게속…","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"https://voidsatisfaction.github.io/tags/Redux/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"Project Euler 121","slug":"2016-9-27-a-ProjectEuler","date":"2016-09-26T16:38:09.000Z","updated":"2016-09-26T16:42:42.000Z","comments":true,"path":"2016/09/27/2016-9-27-a-ProjectEuler/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/27/2016-9-27-a-ProjectEuler/","excerpt":"","text":"ProblemDisc game prize fundProblem 121 A bag contains one red disc and one blue disc. In a game of chance a player takes a disc at random and its colour is noted. After each turn the disc is returned to the bag, an extra red disc is added, and another disc is taken at random. The player pays £1 to play and wins if they have taken more blue discs than red discs at the end of the game. If the game is played for four turns, the probability of a player winning is exactly 11/120, and so the maximum prize fund the banker should allocate for winning in this game would be £10 before they would expect to incur a loss. Note that any payout will be a whole number of pounds and also includes the original £1 paid to play the game, so in the example given the player actually wins £9. Find the maximum prize fund that should be allocated to a single game in which fifteen turns are played. Solution Get the all posibilities player lose(using combination) Then, get the winning rate of player for this game Get maximum prize 1234567891011121314151617181920class Problem121 def self.find_ans total_lose = 0 8.upto(15) do |lose| total_lose += (1..15).to_a.combination(lose).to_a.map&#123; |e| e.reduce(:*) &#125;.reduce(:+) end winning_rate = 1 - Rational(total_lose,factorial(16)) prize = (1/winning_rate).floor end def self.factorial(num) result = 1 num.downto(1) do |i| result *= i end result endendp Problem121.find_ans","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"},{"name":"Project Euler","slug":"Project-Euler","permalink":"https://voidsatisfaction.github.io/tags/Project-Euler/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"},{"name":"Project Euler","slug":"Ruby/Project-Euler","permalink":"https://voidsatisfaction.github.io/categories/Ruby/Project-Euler/"}]},{"title":"기여도 1%의 의미","slug":"2016-9-23-a-1:100","date":"2016-09-23T11:52:00.000Z","updated":"2016-09-27T07:53:43.000Z","comments":true,"path":"2016/09/23/2016-9-23-a-1:100/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/23/2016-9-23-a-1:100/","excerpt":"","text":"드디어 나의 첫 pull request가 반영되었다! 총 코드변동량 : 약 80,000 나의 코드변동량 : 약 800 나의 기여도 : 1% 기여도 1%얼마전에 나는 정말 오랜만에 짜릿한 경험을 했다. 현재 나와 사부님이 같이 진행하는 프로젝트에서 까다로운 여러 테스트(퍼포먼스 리뷰, 코드 리뷰, Eslint)를 잘 극복해서 드디어! 프로젝트를 시작한지 어언 4개월만에 처음으로 Pull Request가 받아들여서 Master에 Merge되는 영광을 누렸다. 약 4개월 전 처음 React Native에 입문했을때 나에게는 너무나도 낯선것들 투성이였다. 가장 먼저, 나는 항상 Ruby만 써왔기 때문에 React Native의 모든것들이 다 낯설었다. state와 props flex 시스템 상속 flux / redux xcode simulator npm … (redux는 아직도 잘 모르겠다.) 앞서 나열한 모든 개념들이 내게는 낯설었고 도대체 어디서부터 어떻게 공부해야할지 몰랐다. 그리고 너무나도 모르는게 많아서 내가 사부와 같은 위치에서 기술에 대해서 토론하고 코드를 작성할 수 있을거라고는 상상도 못했었다. 그런데 그게 현실로 되었다. 사실 4개월동안 계속 React Native만 공부한 것은 아니었다. 도중에는 회의감이 들어서 당분간 React Native의 코드는 처다도 보지 않았던 때도, 대학원 시험공부에 쫓겨서 한달정도는 전혀 코드를 만지지 않았던 때도 있었다. 그래도 포기 않고 하나하나 사부가 하라는 것을 해나가니 첫 Pull Request까지 성공하게 되었다. 이제 겨우 첫 공헌이고 겨우 기여도 1%에 불과하다고 생각할 수도 있지만, 나에게는 매우 크나큰 의미를 가지고 있는 1%라고 생각한다. 마치 닐 암스트롱이 달에 첫 깃발을 꽂듯이, 콜럼버스가 신 대륙을 발견하듯이, 아리스토텔레스가 욕조속에서 유레카를 외치듯이.. 이 1%는 앞으로 내가 개발자 / 엔지니어 / 프로그래밍을 사랑하는 사람으로서 크나큰 1%가 되리라 확신한다. 왜냐하면 나는 내 1%를 정말 자랑스럽게 생각하기 때문이다. 이 글을 보는 다른 사람들과 미래의 나에게 지금 이 행복한 기분을 전달하고자 이 글을 쓴다. 나의 위대한 1%를 기리며","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"},{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Xcode버전업과 RN개발환경 오류들","slug":"2016-9-19-a-rnerrors","date":"2016-09-19T02:52:00.000Z","updated":"2016-09-26T15:47:35.000Z","comments":true,"path":"2016/09/19/2016-9-19-a-rnerrors/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/19/2016-9-19-a-rnerrors/","excerpt":"","text":"이 글을 쓰게 되는 계기는 다름이 아니라 몇가지 에러로 인하여 나와 사부가 정말 말 그대로 하루종일 고생했다는 점이다. 그래서 앞으로 이러한 에러가 나올 경우에 잘 대처할 수 있도록 머리에 담아두고자 이곳에 글을 쓴다. 발단 : Git사용의 미숙함 + Xcode업데이트Remote에서 git pull을 한 이후로 이상하게 simulator가 실행되지 않는 버그가 발생했다. 그리고, 나는 그것이 Xcode가 업데이트되지 않았기 때문에 발생한 문제라고 생각했다. 그래서 나는, 끔찍한 미래가 기다리는 것도 모른채 RN노드 모듈을 전부 삭제하고 다시 깔고, cache도 전부 지웠다 다시 깔았으며, xcode마저 업데이트 했다. 해결해결은 다음과 같은 순서로 행해졌다. 1. xcode업데이트에 의한 websocket오류 =&gt; RCTWebSocket의 Custom Compiler Flag의 value 제거 2. terminal상에서 무엇이 에러인지 모를때 =&gt; xcode에서 build후 error를 추출한다.3. xcode를 build할때 =&gt; 흰색으로 열어라4. linker library지원 (7.0버전 설정을 로컬에 맞는 9.1로 변환) 5. suitable library 오류 =&gt; 시뮬레이터를 ios10 에서 ios9로 실행을 바꿈(없으면 새로 다운받아야함)123456789dyld: Library not loaded: @rpath/libFirestack.a Referenced from: /Users/tech-camp-064/Library/Developer/CoreSimulator/Devices/3692613C-5EBB-4BAD-9496-C336B2629BC8/data/Containers/Bundle/Application/D73B751F-39B9-4230-818A-C7C5BF5B7C66/SchoolShare.app/SchoolShare Reason: no suitable image found. Did find: /Users/tech-camp-064/Library/Developer/Xcode/DerivedData/SchoolShare-dlacbtwbdazihdgkeyjricajfoer/Build/Products/Debug-iphonesimulator/libFirestack.a: required code signature missing for &apos;/Users/tech-camp-064/Library/Developer/Xcode/DerivedData/SchoolShare-dlacbtwbdazihdgkeyjricajfoer/Build/Products/Debug-iphonesimulator/libFirestack.a&apos;(lldb) 6. 무슨 이유인지 모르겠지만 npm install을 해도 존재하지 않다고 하면 그것은 수동으로 npm i 해줘야 한다 이와같은 방식으로 해결했다. 교훈 xcode업데이트는 팀원과 협의하에 행해야 한다. terminal상에서 error의 내용을 잘 확인할 수 없을때에는 xcode에서 build하면 단서를 얻을 수 있다. xcode를 틈틈이 공부할 수 있으면 참 좋을것 같다. 그래도 오늘도 굴복하지 말고 Happy Coding!","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"오늘 또 느낀 것들...","slug":"2016-9-09-a-gitandmygit","date":"2016-09-09T02:52:00.000Z","updated":"2016-09-26T15:57:24.000Z","comments":true,"path":"2016/09/09/2016-9-09-a-gitandmygit/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/09/2016-9-09-a-gitandmygit/","excerpt":"","text":"최근에 했던 것오늘은 그동안 내가 작업했던 일을 갈무리 짓는 날이었다. 솔직히 얘기하자면 하는 일이 그렇게 엄청 대단한 것은 아니고, React Native의 Component 들을 Atomic Design에 맞게 리팩토링 하는 일을 했다. 애초에 나 자신이 작성한 코드가 아니었기때문에 코드를 분석하는 것 부터가 일이었으며, 분석한 뒤에도 모르는 것 투성이었다. 그래도 일단은 Atomic Design에 관한 글과, 사부의 설명을 들으면서 하나하나 정리해 나가기 시작했다. 그랬더니 처음에는 엄청나게 막연하게 ‘너무 힘들 것 같다’라고 생각되었던 일들이 생각보다 ‘할만 하구나’라는 생각이 들었다. 내가 했던 일을 잠깐 설명해보자면 AddNewLecture이라는 하나의 Screen을 Organisms, Molecules, Atoms까지 분해하여서 Module화 시키는 것이었다. 그리고 이렇게 모듈화를 시키므로써, 어플리케이션의 구조를 중복을 제거함과 동시에 재활용가능하게 하는 것이었다. 또한, Proptypes를 이용하여 보다 엄밀하게 기능을 제어할 수 있도록 했다. 그리고 그 과정은 Screen을 복사 분해 합성 이렇게 처리하였다. 또 다시 높은 산이렇게 전부 코드를 처리하고 난 다음 나의 기분은 정말 뿌듯했다. ‘이제는 나도 일인분은 할 수 있겠구나’라고 생각했다. 그러나 처리한 일을 기존의 일과 병합하는 과정에서 큰 난관에 봉착했다. 원래 내가 작업하고있던 파일들은 local환경에서 새로운 branch를 만들어서 작업중이었다. 나는 그것을 한차례 수정이된 remote환경의 master의 내용을 내 local환경의 master branch에 적용한 뒤 다시 그 내용을 local의 새 브랜치에 merge하고 그 내용을 다시 remote에 push해서 pull request에 관한 내용을 작성 해야만했는데, 2에서 merge하는 과정에 내가 무엇인가를 잘못헀는지 엄청나게 많은 오류가 뜨면서 많은 파일들이 수정되어버렸다. 아차차 싶어서 사부에게 결과를 말한 뒤, 사부의 제안에 따라서 SourceTree라는 프로그램을 다운로드 받아서 다시 commit직후의 상태로 되돌릴 수 있었다. 그러나 npm install이후 npm test에서 eslint에 관한 수많은 error들 pull request를 작성한 것들에 대한 사부의 신랄한 코멘트 “앞으로는 그냥 commandline git대신 SourceTree로 하세요.” 를 보면서 약간 자존심에 금이갔다. 그래도 난 나름대로 잘 했다고 생각했는데, 나의 욕심으로 정상만을 바라보다 그만 눈 앞의 돌에 고꾸라 넘어져버렸다. 그래도 그냥, 천천히, 올라야지그래도 나는 산을 오르는것을 힘들어할 망정 포기하지는 않을 것이다. 내가 갖고 있는 나만의 장점 중 하나는, ‘위기를 기회로 바꾸는 마음가짐’에 있다고 생각한다. 내 앞에 크나큰 산들이 가로막고, 그 산들이 얼마나 더 많이 있는지 모르지만 나는 이 위기를 기회로 바꾸어서 내가 한결 나아갈 수 있도록 해야겠다. 이렇게 한 번 넘어졌을때야 말로 바로 내가 가장 나 다워질 수 있는 시기이자, 내게는 기회다. 그래 지금 산을 오르는 과정에서 한 번 넘어졌어도, 그래도 그냥, 천천히, 올라야지. 앞으로 해야 할 Task ESlint Error처리 + github feedback =&gt; npm test =&gt; remote push =&gt; merge Git / Github 이해될 때 까지 해보자. 한 번 누가 이기나 해보자. SourceTree npm test에 대하여","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Nodejs 공부기 4 ~ Session & Password & Socket.io","slug":"2016-9-03-b-securitysocketio","date":"2016-09-03T02:52:00.000Z","updated":"2016-09-26T15:46:18.000Z","comments":true,"path":"2016/09/03/2016-9-03-b-securitysocketio/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/03/2016-9-03-b-securitysocketio/","excerpt":"","text":"layout: post title: Nodejs 공부기4 ~ Session &amp; Password &amp; Socket.io포인트 Session Client에 저장하는 것은 sessionid뿐. 실질적인 데이터는 서버에. Password md5 + salt(global, respective) sha512 + salt PBKDF2 Socket.io 정의는아직 실시간 어플리케이션(채팅, 캐치마인드) Real codeSession123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const express = require('express')const session = require('express-session')const FileStore = require('session-file-store')(session)const bodyParser = require('body-parser')const pug = require('pug')const app = express()app.set('views', './views')app.set('view engine', 'pug')app.use(session(&#123; store: new FileStore(), secret: 'wefjwoefkwlefmwlkm', resave: false, saveUninitialized: true,&#125;))app.use(bodyParser.urlencoded(&#123; extended: false &#125;))// this scope!const userDB = &#123; findUser: function(id,password)&#123; if (!this.allUsers[id] || this.allUsers[id]['password'] != password) &#123; return false &#125; else &#123; return true &#125; &#125;, allUsers: &#123; admin: &#123; password: '123' &#125;, nersery: &#123; password: '123123' &#125;, lionking: &#123; password: '123' &#125; &#125;&#125;// req.session.countapp.get('/login', (req, res) =&gt; &#123; if (req.session.userInfo) &#123; res.redirect('/welcome') &#125; else &#123; errorMessage = req.session.err res.render('login',&#123;errorMessage: errorMessage&#125;) &#125;&#125;)app.post('/login', (req, res) =&gt; &#123; const userId = req.body.userId const userPassword = req.body.userPassword if (userDB.findUser(userId,userPassword)) &#123; delete req.session.err req.session.userInfo = &#123; id: userId &#125; res.redirect('/welcome') &#125; else &#123; req.session.err = 'Check your id or password' res.redirect('/login') &#125;&#125;)app.get('/logout', (req, res) =&gt; &#123; delete req.session.errorMessage delete req.session.userInfo res.redirect('/login')&#125;)app.get('/register', (req, res) =&gt; &#123; if (req.session.userInfo) &#123; res.redirect('/welcome') &#125; else if(req.session.errorMessage)&#123; res.render('register',&#123;errorMessage: req.session.errorMessage&#125;) &#125; else &#123; res.render('register') &#125;&#125;)app.post('/register', (req, res) =&gt; &#123; const userId = req.body.userId const userPassword = req.body.userPassword const userPasswordConfirm = req.body.userPasswordConfirm if (userDB.allUsers[userId]) &#123; req.session.errorMessage = 'the id is already exist' &#125; else if(userPassword.length &lt; 3)&#123; req.session.errorMessage = 'your password should be more than 3 characters' &#125; else if(userPassword !== userPasswordConfirm)&#123; req.session.errorMessage = 'Password is not correct with Password confirm' &#125; else &#123; delete req.session.errorMessage userDB.allUsers[userId] = &#123; password: userPassword&#125; req.session.userInfo = &#123;id: userId&#125; req.session.save(() =&gt; &#123; res.redirect('/welcome') &#125;) &#125; res.redirect('/register')&#125;)app.get('/welcome', (req, res) =&gt; &#123; const userId = req.session.userInfo.id res.render('welcome', &#123;userId: userId&#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log('Connected at 3000 port!')&#125;) Socket.iojs part123456789101112131415161718const app = require('express')()const http = require('http').Server(app)const io = require('socket.io')(http)app.get('/', (req, res) =&gt; &#123; res.sendFile(__dirname + '/views/index.html')&#125;)io.on('connection', (socket) =&gt; &#123; socket.on('chat message', (msg) =&gt; &#123; io.emit('chat message', msg) &#125;)&#125;)http.listen(3000, () =&gt; &#123; console.log('Connected at 3000 port!')&#125;) html part12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"messages\"&gt;&lt;/ul&gt; &lt;form&gt; &lt;input id=\"m\" type=\"text\" autocomplete=\"off\" /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; const socket = io() $('form').submit( () =&gt; &#123; socket.emit('chat message', $('#m').val()) $('#m').val('') return false &#125;) socket.on('chat message', (msg) =&gt; &#123; $('#messages').append($('&lt;li&gt;').text(msg)) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 참조 생활코딩 Password 보안 Socket.io Getting Started","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"Socket.io","slug":"Socket-io","permalink":"https://voidsatisfaction.github.io/tags/Socket-io/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}]},{"title":"JavaScript 공부기 ~ this, bind, apply","slug":"2016-9-02-a-thisapply","date":"2016-09-02T02:52:00.000Z","updated":"2016-09-26T16:05:18.000Z","comments":true,"path":"2016/09/02/2016-9-02-a-thisapply/","link":"","permalink":"https://voidsatisfaction.github.io/2016/09/02/2016-9-02-a-thisapply/","excerpt":"","text":"포인트 This의 사용 객체의 소속인 메소드의 this는 그 객체를 가르킨다. 아무것도 없을 경우는 window객체 Bind bind는 어떤 객체에 종속되어 있는 함수의 this의 문맥을 명시적으로 변경시키기 위해서 사용한다. Apply apply는 일시적으로 어떠한 함수를 다른 객체에서 사용할 수 있도록 하기 위해서 사용한다. Real codeThis 예제12345678910111213141516171819const userDB = &#123; findUser: function(id,password)&#123; if (!this.allUsers[id] || this.allUsers[id]['password'] != password) &#123; return false &#125; else &#123; return true &#125; &#125;, allUsers: &#123; admin: &#123; password: '123' &#125;, nersery: &#123; password: '123123' &#125;, lionking: &#123; password: '123' &#125; &#125; Bind예제React Native 공부기1 ~ bind 편 참조 Apply예제123456789101112131415161718var o = &#123;&#125;var p = &#123;&#125;function func()&#123; switch(this)&#123; case o: document.write('o&lt;br /&gt;'); break; case p: document.write('p&lt;br /&gt;'); break; case window: document.write('window&lt;br /&gt;'); break; &#125;&#125;func();func.apply(o);func.apply(p); 참조 생활코딩 this","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"},{"name":"Grammar","slug":"Grammar","permalink":"https://voidsatisfaction.github.io/tags/Grammar/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}]},{"title":"Give It Five Minutes","slug":"2016-8-26-a-giveItFiveMinutes","date":"2016-08-26T02:52:00.000Z","updated":"2016-09-26T15:44:15.000Z","comments":true,"path":"2016/08/26/2016-8-26-a-giveItFiveMinutes/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/26/2016-8-26-a-giveItFiveMinutes/","excerpt":"","text":"출처Give It Five Minutes 내가 읽은 2016최고의 글이다. 언제나 마음속에 내 철학으로 새겨둬야지. 이곳에 올린 이유는, 계속 마음에 품기 위해서. 그리고 이렇게 좋고 멋있는 글이 사라질까 두려워서. Give it five minutesI used to be a hothead. Whenever anyone said anything, I’d think of a way to disagree. I’d push back hard if something didn’t fit my world-view. It’s like I had to be first with an opinion — as if being first meant something. But what it really meant was that I wasn’t thinking hard enough about the problem. The faster you react, the less you think. Not always, but often. It’s easy to talk about knee jerk reactions as if they are things that only other people have. You have them too. If your neighbor isn’t immune, neither are you. This came to a head back in 2007. I was speaking at the Business Innovation Factory conference in Providence, RI. So was Richard Saul Wurman. After my talk Richard came up to introduce himself and compliment my talk. That was very generous of him. He certainly didn’t have to do that. And what did I do? I pushed back at him about the talk he gave. While he was making his points on stage, I was taking an inventory of the things I didn’t agree with. And when presented with an opportunity to speak with him, I quickly pushed back at some of his ideas. I must have seemed like such an asshole. His response changed my life. It was a simple thing. He said “Man, give it five minutes.” I asked him what he meant by that? He said, it’s fine to disagree, it’s fine to push back, it’s great to have strong opinions and beliefs, but give my ideas some time to set in before you’re sure you want to argue against them. “Five minutes” represented “think”, not react. He was totally right. I came into the discussion looking to prove something, not learn something. This was a big moment for me. Richard has spent his career thinking about these problems. He’s given it 30 years. And I gave it just a few minutes. Now, certainly he can be wrong and I could be right, but it’s better to think deeply about something first before being so certain you’re right. There’s also a difference between asking questions and pushing back. Pushing back means you already think you know. Asking questions means you want to know. Ask more questions. Learning to think first rather than react quick is a life long pursuit. It’s tough. I still get hot sometimes when I shouldn’t. But I’m really enjoying all the benefits of getting better. If you aren’t sure why this is important, think about this quote from Jonathan Ive regarding Steve Jobs’ reverence for ideas: And just as Steve loved ideas, and loved making stuff, he treated the process of creativity with a rare and a wonderful reverence. You see, I think he better than anyone understood that while ideas ultimately can be so powerful, they begin as fragile, barely formed thoughts, so easily missed, so easily compromised, so easily just squished. That’s deep. Ideas are fragile. They often start powerless. They’re barely there, so easy to ignore or skip or miss. There are two things in this world that take no skill: 1. Spending other people’s money and 2. Dismissing an idea. Dismissing an idea is so easy because it doesn’t involve any work. You can scoff at it. You can ignore it. You can puff some smoke at it. That’s easy. The hard thing to do is protect it, think about it, let it marinate, explore it, riff on it, and try it. The right idea could start out life as the wrong idea. So next time you hear something, or someone, talk about an idea, pitch an idea, or suggest an idea, give it five minutes. Think about it a little bit before pushing back, before saying it’s too hard or it’s too much work. Those things may be true, but there may be another truth in there too: It may be worth it.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"프로그래밍 공부에 도움이 되는 사이트","slug":"3018-8-18-c-ProgrammingSite","date":"2016-08-25T02:52:00.000Z","updated":"2016-11-16T04:38:16.000Z","comments":true,"path":"2016/08/25/3018-8-18-c-ProgrammingSite/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/25/3018-8-18-c-ProgrammingSite/","excerpt":"","text":"프로그래밍(주로 웹) 공부에 도움이 되는 사이트를 모아보았습니다. 웹 기초웹의 기초적인 부분을 배울 수 있는 사이트들 입니다. 생활코딩Codelion멋쟁이 사자처럼CodecademyCss 레이아웃을 배웁시다웹 기본Node School알고리즘Euler Project(오일러 프로젝트 한글)Euler Project(영문)Google codejamTop Coder해킹 / 보안해커스쿨webhacking.krToolsGitHub / GitGit간편 안내서Git 쉽게 따라 배우기Vim Adventure좋은 블로그 / 팟캐스트나는 프로그래머다More Agile 보다 나은 개발자가 되기 위하여쪼꼬니 님의 블로그(웹디자인에 참고. 내용정리가 잘되어있음)기타Google Power Search","categories":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}],"tags":[{"name":"프로그래밍 교육","slug":"프로그래밍-교육","permalink":"https://voidsatisfaction.github.io/tags/프로그래밍-교육/"}],"keywords":[{"name":"교육","slug":"교육","permalink":"https://voidsatisfaction.github.io/categories/교육/"}]},{"title":"Callback / Clojure / Continuation","slug":"2016-8-25-a-cbcjcn","date":"2016-08-25T02:52:00.000Z","updated":"2016-09-26T16:04:50.000Z","comments":true,"path":"2016/08/25/2016-8-25-a-cbcjcn/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/25/2016-8-25-a-cbcjcn/","excerpt":"","text":"배경콜백과 클로저는 JavaScript를 배우거나 OpenGL에서 본 개념이다.계속은 The Little Schemer에서 본 개념인데 너무 헷갈려서 정리해 놓는다. 계속 때문에 머리가 터질 것 같다 참조 히오키 선생님의 스킴(일문) 継続 JavaScript정리 리터럴부터 클로저까지 나무위키 포인트 콜백 함수에 인자로 넘겨지는 함수 함수에 인자로 넘겨지므로써 그 함수에 따른 기능을 하도록 한다. ex) Nodejs에서 req res에서의 콜백, OpenGL에서의 keyfuc콜백 클로저 클로저는 함수가 선언될 당시의 환경을 기억했다가 나중에 호출되었을때 원래의 환경에 따라 수행되는 함수이다. 계속 actor(lamda function)가 값과 처리방식을 다음 actor에 넘겨준다. 다음 actor은 값을 다른 actor에 넘겨주거나 처리하거나 할 수 있다. 콜백예시1234567891011121314151617//메인 프로그램function MainProgram &#123; var arg; LibFunc(arg, CallbackFunc);&#125;//콜백 함수function CallbackFunc(result) &#123; //result 이용&#125;//라이브러리 함수function LibFunc(arg, callback) &#123; var data; // 작업수행 callback(data);&#125; 클로저예시12345678910111213function outer() &#123; var x=0; return function() &#123; return ++x; &#125;&#125;var x=-1;var f= outer();console.log(x); // -1console.log(f()); //1console.log(f()); //2console.log(f()); //3 예시2 : 초기화12345678910111213function outer() &#123; var x=0; return function()&#123; return ++x; &#125;&#125;var x=-1;outer(); //function()&#123; return ++x; &#125;console.log(x); // -1console.log(outer()()); //1console.log(outer()()); //1console.log(outer()()); //1 예시3 : 클로저 인스턴스123456789101112131415161718function outer() &#123; var x=0; return function() &#123; return ++x; &#125;&#125;var x=-1;var f= outer(); //인스턴스 하나를 선언하는 효과다!!var g= outer(); //이렇게 하면 별도의 인스턴스로 생성된다.console.log(x); // -1console.log(f()); //1console.log(f()); //2console.log(f()); //3console.log(g()); //1 //새롭게 1부터 시작하는 것을 볼 수 있다.console.log(g()); //2console.log(g()); //3 클로저는 비공개 내부 변수를 갖는 함수 인스턴스 생성자이다. 클로저로 생성한 독립된 변수 공간을 가진 인스턴스를 클로저 인스턴스라고 한다. Q) 근데 결국 클로저를 어따가 쓰는거지? 계속12345(define fact (lambda n c) (if (= n c 1 ) (fact (- n 1) (lambda (a) (c (* n a)))))))","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"ECMA Script6","slug":"JavaScript/ECMA-Script6","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/ECMA-Script6/"}]},{"title":"React Native 공부기 1 ~ bind","slug":"2016-8-24-b-rn","date":"2016-08-24T12:52:00.000Z","updated":"2016-09-26T15:38:17.000Z","comments":true,"path":"2016/08/24/2016-8-24-b-rn/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/24/2016-8-24-b-rn/","excerpt":"","text":"포인트bind는 this의 scope를 제어하기 위한 메소드이다. Real codeCore 부분1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default class Stopwatch extends Component &#123; componentWillMount() &#123; this.setState(&#123; mainTime: 0, subTime: 0, timerOn: false, &#125;) &#125; render() &#123; console.log(this.state) return ( &lt;View&gt; &lt;Buttons startTime=&#123;this._startTime&#125; stopTime=&#123;this._stopTime&#125; stopWatch=&#123;this&#125;/&gt; &lt;/View&gt; ); &#125; _startTime()&#123; if (!this.state.timerOn)&#123; var timer = setInterval(() =&gt; &#123; let mainTime = this.state.mainTime let subTime = this.state.subTime this.setState(&#123; mainTime: mainTime + 1, subTime: subTime + 1, &#125;) &#125;, 100) this.setState(&#123; timer: timer, timerOn: true, &#125;) &#125; &#125; _stopTime() &#123; clearInterval(this.state.timer) this.setState(&#123; timerOn: false, &#125;) &#125;&#125; 위의 코드에서 주목할 부분은 Buttons라는 컴포넌트에 stopWatch={this}즉,props를 이용하여 this 전체를 건네주고 있다는 점이다. Buttons 컴포넌트1234567891011121314151617181920212223class Buttons extends Component &#123; render() &#123; return ( &lt;View style=&#123;day1Style.buttons&#125;&gt; &lt;TouchableOpacity style=&#123;day1Style.button&#125; onPress=&#123;this.props.startTime.bind(this.props.stopWatch)&#125;&gt; &lt;Text&gt; start &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity style=&#123;day1Style.button&#125; onPress=&#123;this.props.stopTime.bind(this.props.stopWatch)&#125;&gt; &lt;Text&gt; End &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125; 그리고 Buttons라는 component를 보면 TouchableOpacity의 onPress속성에서this.props.startTime.bind(this.props.stopWatch)로 되어있는것을 알 수 있다. 여기서 왜 bind(this.props.stopWatch)를 해야만 하는가 하면그냥 this.props.startTime을 실행해버리면startTime함수 안의 this가 Buttons의 this가 되어버리기 때문이다. 우리가 제어하고 싶은 state는 Stopwatch component에 존재하기 때문에startTime함수의 this의 scope를 Stopwatch에 bind시켜줄 필요가 있다. 따라서 bind(this.props.stopWatch) 즉, bind(Stopwatch component 전체)로 this를 고정시켜줌으로써이러한 문제를 해결시켜줄 수 있다. 참조 RN JS 연습 - 3 Use of the JavaScript ‘bind’ method","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://voidsatisfaction.github.io/tags/React-Native/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"React Native","slug":"JavaScript/React-Native","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/React-Native/"}]},{"title":"Nodejs 공부기 3 ~ Web Application만들기","slug":"2016-8-24-a-nodestudy3","date":"2016-08-24T02:52:00.000Z","updated":"2016-09-26T15:37:05.000Z","comments":true,"path":"2016/08/24/2016-8-24-a-nodestudy3/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/24/2016-8-24-a-nodestudy3/","excerpt":"","text":"선생님생활코딩 Nodejs 배운 내용들 우리는 비게 오게 해달라 오지 않게 해달라고 기도한다. 하지만 진정한 기도는 비가 와도 오지 않아도 자기자신이 흔들리지 않게 해달라는 해탈을 위한 기도이다. 고생고생해서 CRUD하나 만들었는데 확실히 Nodejs가 편리한 면이 있다.그러나 앱을 만드는데에 있어서 중요한 것은한번에 다 하려고 하지 않고 하나한 차근차근 해나가는 것이다.즉, 기획을 완벽히 하고 앱을 제작하자. 여기서 기획이라 함은 어떠한 객체가 어떻게 작용하는지, 어떤 흐름으로 작동하는지를명확히 한 것을 의미한다. 백날 디버깅하는 것 보다 한 번 기획을 잘하는 것이 효율적이다. Real code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const express = require('express')const app = express()const bodyParser = require('body-parser')const Oriento = require('oriento');const server = Oriento(&#123; host: 'localhost', port: 2424, username: 'root', password: '***' // You should save password on config file for proper security&#125;);var db = server.use('o2')console.log('Using database: ' + db.name)app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.locals.pretty = trueapp.set('views', './views')app.set('view engine', 'pug')app.get('/topic/add', (req, res) =&gt; &#123; res.render('add')&#125;)app.post('/topic/add', (req, res) =&gt; &#123; const title = req.body.post_title const name = req.body.post_name const description = req.body.post_description const sql = 'INSERT INTO topic (title, author, description) VALUES(:title, :name, :description)' db.query(sql, &#123;params: &#123;title: title, name: name, description: description&#125;&#125;).then((result) =&gt; &#123; console.log(result) const id = encodeURIComponent(result['@rid']) res.redirect('/topic/') &#125;)&#125;)app.get('/topic/:id/edit', (req, res) =&gt; &#123; const id = decodeURIComponent(req.params.id) const sql = 'SELECT FROM topic where @rid=:rid' db.query(sql, &#123;params: &#123;rid: id&#125;&#125;).then((topic) =&gt; &#123; console.log(topic) res.render('edit', &#123;topic: topic[0]&#125;) // Be careful!! topic[0] &#125;)&#125;)app.post('/topic/:id/edit', (req, res) =&gt; &#123; const rid = decodeURIComponent(req.params.id) const title = req.body.post_title const name = req.body.post_name const description = req.body.post_description const sql = `UPDATE topic SET title=:title, author=:name, description=:description WHERE @rid=:rid` //no comma plz db.query(sql, &#123; params: &#123; rid: rid, title: title, name: name, description: description&#125; &#125;).then((topic) =&gt; &#123; console.log('edit complete') res.redirect('/topic/' + encodeURIComponent(req.params.id)) &#125;)&#125;)app.get('/topic/:id/delete', (req, res) =&gt; &#123; const rid = decodeURIComponent(req.params.id) const sql = 'DELETE FROM topic WHERE @rid=:rid' db.query(sql, &#123;params: &#123;rid: rid&#125;&#125;).then((result) =&gt; &#123; console.log('delete successfully') res.redirect('/topic/') &#125;)&#125;)app.get(['/topic', '/topic/:id'], (req, res) =&gt; &#123; const sql = 'SELECT FROM topic' db.query(sql).then((results) =&gt; &#123; if (req.params.id) &#123; const id = decodeURIComponent(req.params.id) const sql2 = 'SELECT FROM topic WHERE @rid=:rid' // rid should be placed inside of next's params! db.query(sql2, &#123;params: &#123;rid: id&#125;&#125;).then((topic) =&gt; &#123; console.log(topic) res.render('topic', &#123;topic: topic[0], topics: results&#125;) &#125;) &#125; else &#123; res.render('topic', &#123;topic: &#123;title: 'Welcome!', name: 'Master', description: 'Practicing'&#125;, topics: results&#125;) &#125; &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log('Server connected at 3000!')&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://voidsatisfaction.github.io/tags/Nodejs/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}]},{"title":"Nodejs 공부기 2","slug":"2016-8-23-c-nodestudy2","date":"2016-08-23T14:59:00.000Z","updated":"2016-09-26T15:36:03.000Z","comments":true,"path":"2016/08/23/2016-8-23-c-nodestudy2/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/23/2016-8-23-c-nodestudy2/","excerpt":"","text":"선생님생활코딩 Nodejs 배운 내용들File Based Web App Get / Post Get : Using URL Post : No URL bodyParser Web App Making CR(UD) Removing Overlapped Expression File Uploading Multer ETC Nodejs Auto-restart(supervisor module) Real codeApp.js(CR,File upload)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const express = require('express')const bodyParser = require('body-parser')const multer = require('multer')const _storage = multer.diskStorage(&#123; destination: (req, file, cb) =&gt; &#123; cb(null, 'uploads/') &#125;, filename: (req, file, cb) =&gt; &#123; cb(null, file.originalname + '-' + Date.now()) &#125;&#125;)const upload = multer(&#123; storage: _storage &#125;)const fs = require('fs')const app = express()app.use('/user', express.static('uploads')) // uploads에 있는 파일들을 /user라는 url을통해서 서비스 하겠다. (유저가 갖고 갈 수 있게 함.)app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.set('views', './views')app.set('view engine', 'pug')app.get('/', (req, res) =&gt; &#123; res.send('hi fool!' )&#125;)app.get('/upload', (req, res) =&gt; &#123; res.render('upload')&#125;)// Middle ware first(processing)app.post('/upload', upload.single('userfile'), (req, res) =&gt; &#123; console.log(req.file) res.send('Uploaded : ' + req.file.filename)&#125;)app.get('/topic/new', (req, res) =&gt; &#123; fs.readdir('data', (err, files) =&gt; &#123; if (err) &#123; console.log(err) res.status(500).send('Internal Server Error') &#125; res.render('new', &#123; topics: files&#125;) &#125;)&#125;)app.get(['/topic', '/topic/:id'], (req, res) =&gt; &#123; fs.readdir('data', (err, files) =&gt; &#123; if (err) &#123; console.log(err) res.status(500).send('Internal Server Error') &#125; const id = req.params.id if (id) &#123; fs.readFile(`data/$&#123;id&#125;`, 'utf8', (err, data) =&gt; &#123; if (err) &#123; console.log(err) res.status(500).send('Internal Server Error') &#125; res.render('view', &#123; title: id, topics: files, description: data&#125;) &#125;) &#125; else &#123; res.render('view', &#123; topics: files, title: 'Welcome', description: 'Hello, JavaScript for server.' &#125;) &#125; &#125;)&#125;)app.post('/topic', (req, res) =&gt; &#123; const title = req.body.title const description = req.body.description fs.writeFile(`data/$&#123;title&#125;`,description, (err) =&gt; &#123; if (err) &#123; res.status(500).send('Internal Server Error!') &#125; res.redirect('/topic') &#125;)&#125;)app.listen(3000, () =&gt; &#123; console.log('Connected at 3000port!')&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://voidsatisfaction.github.io/tags/Nodejs/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/"},{"name":"Nodejs","slug":"JavaScript/Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript/Nodejs/"}]},{"title":"Scheme의 아름다움 ~ Continuation","slug":"2016-8-23-b-schemestudy","date":"2016-08-23T14:52:00.000Z","updated":"2016-09-26T15:34:04.000Z","comments":true,"path":"2016/08/23/2016-8-23-b-schemestudy/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/23/2016-8-23-b-schemestudy/","excerpt":"","text":"선생님The Little Schemer 배운 내용들 lambda 함수의 return값으로 함수를 건네줄 수 있다. 그 함수는 lambda함수를 이용해서 건네줄 수 있다. Collecter 함수가 여러 값을 나타낼 수 있도록 도와준다. 값의 Collect 아직 완벽하지 이해하지는 못했으나 정말 아름다워 보인다. Real code예제11234567891011121314151617181920212223242526272829303132333435363738#| Remeber more than two value at a time |#(define (multiinsertLR new oldL oldR lat) (cond ((null? lat) '()) ((eq? oldL (car lat)) (cons new (cons oldL (multiinsertLR new oldL oldR (cdr lat))))) ((eq? oldR (car lat)) (cons oldR (cons new (multiinsertLR new oldL oldR (cdr lat))))) (else (cons (car lat) (multiinsertLR new oldL oldR (cdr lat))))))(define (multiinsertLR&amp;co new oldL oldR lat col) (cond ((null? lat) (col '() 0 0)) ((eq? oldL (car lat)) (multiinsertLR&amp;co new oldL oldR (cdr lat) (lambda (newlat L R) (col (cons new (cons oldL newlat)) (+ L 1) R)))) ((eq? oldR (car lat)) (multiinsertLR&amp;co new oldL oldR (cdr lat) (lambda (newlat L R) (col (cons oldR (cons new newlat)) L (+ R 1))))) (else (multiinsertLR&amp;co new oldL oldR (cdr lat) (lambda (newlat L R) (col (cons (car lat) newlat) L R))))))(multiinsertLR&amp;co 'salty 'fish 'chips '(chips and fish or fish and chips) (lambda (lat a b) (cons a (cons b lat)))) 해설만약 위의 multiinsertLR&amp;co함수가(multiinsertLR&amp;co ‘hi ‘animal ‘plant ‘(hello world) col)이렇게 실행된다고 하자. (여기서 col은 아직 미정의) 그러면, 조건 분기에서 다음이 실행된다. (car lat)인 ‘hello는 oldL, oldR과도 다르므로else 이후의 내용이 실행된다.그런데 여기서 바로 (multiinsertLR&amp;co)함수를 인수만 바꿔서 실행한다.특히 바뀌는 것은 col만 바뀌므로 그쪽에만 집중해서 보기로 하자. 두 번째 multiinsertLR&amp;co의 실행에서col =&gt; (lambda (newlat L R) (col (cons (car lat) newlat) L R))즉, 이는 (col (newlat L R) (col (cons (car lat) newlat) L R))과도 동일하다. 풀어서 얘기하자면, 두번째 multiinsertLR&amp;co는 col에 대한부분이(col (newlat L R) (col (cons (car lat) newlat) L R)) 이렇게 변하는 것이며,(car lat)이 ‘hello 였으므로,(col (newlat L R) (col (cons ‘hello newlat) L R))이 col 인자로 넘어가게 된다. 다음 프로세스(car lat)인 ‘world는 oldL, oldR과도 다르므로else 이후의 내용이 실행된다.그리고 마찬가지로 col만 변화가 되므로 col에만 집중해서 보자. 세번째 multiinsertLR&amp;co의 실행에서col =&gt; (lambda (newlat L R) (col (cons ‘world newlat) L R))여기서 주목해야할 것은 화살표 왼쪽의 col과 오른쪽의 col을 구별하는 것이다.왼쪽의 col은 앞으로 col의 자리에 넘겨주게 될 함수의 인자를 의미하는 것이며,오른쪽의 col은 현재 실행되는 함수의 col을 말하는 것이다. 여기서 우리는 현재 실행되는 함수의 col이 전multiinsertLR&amp;co에서 인자로서 받아온(col (newlat L R) (col (cons ‘hello newlat) L R))이 된다는 것을 알기때문에우리가 다음 multiinsertLR&amp;co에 전해줄 col은col(전해줄 col) =&gt; (lambda (newlat L R) (col(가장 처음의 col) (cons ‘hello (cons ‘world newlat)) L R)) 이렇게 됨을 알 수있다. 마지막 multiinsertLR&amp;co를 실행하면(null? lat)이 참이므로(col ‘() 0 0)이 실행되는데 col은 위에서 받아온 그대로이므로(col (cons ‘hello (cons ‘world ‘())) L R)이 된다.즉, 최종 결과는 (col (hello world) L R)이며,이는 하나의 함수가 리스트를 이용하여 다양한 값을 저장할 수 있다는 것을 의미한다. 예제2 (p.s 정말 아름다운 코드다)1234567891011121314151617181920212223242526272829303132333435363738(define (atom? s) (and (not (pair? s)) (not (null? s))))(define (evens-only* l) (cond ((null? l) '()) ((and (atom? (car l)) (even? (car l))) (cons (car l) (evens-only* (cdr l)))) ((atom? (car l)) (evens-only* (cdr l))) (else (cons (evens-only* (car l)) (evens-only* (cdr l))))))(define (evens-only*&amp;co l col) (cond ((null? l) (col '() 1 0)) ((and (atom? (car l)) (even? (car l))) (evens-only*&amp;co (cdr l) (lambda (newl mul sum) (col (cons (car l) newl) (* (car l) mul) sum)))) ((atom? (car l)) (evens-only*&amp;co (cdr l) (lambda (newl mul sum) (col newl mul (+ (car l) sum))))) (else (evens-only*&amp;co (car l) (lambda (al ap as) (evens-only*&amp;co (cdr l) (lambda (dl dp ds) (col (cons al dl) (* ap dp) (+ as ds)))))))))(evens-only*&amp;co '((9 1 2 8) 3 10 ((9 9) 7 6) 2) (lambda (l mul sum) (cons sum (cons mul l)))) 해설머리로는 이해했으나 가슴으로는 이해하지 못했다. 결국, else이후의 구문이 문제가 되는 것인데여기서 포인트는 아래와 같다. 무엇이 먼저 실행되는가? 12345678(else (evens-only*&amp;co (car l) (lambda (al ap as) (evens-only*&amp;co (cdr l) (lambda (dl dp ds) (col (cons al dl) (* ap dp) (+ as ds))))))))) 만약 우리가 위의 원래의 함수를 어떤 리스트를 넣어서 실행했다고생각한다면 else이후의 내용이 실행되었을때 어떤것들이 어떤순서로 실행될까? 답은 뒤에위치한 앞에있는 evens-only*&amp;co의 부분이 먼저 실행된다는 것이다 그렇다는 얘기는 만일 l이 ‘((hi nice to meet you) my name is amy) 인 경우에(car l)인 리스트가 evens-only*&amp;co의 함수에 input되는 것이 아니라뒷부분의 my 이후의 (cdr l)부분이 먼저 col에 저장된다. 그리고 atom들의 collect가 끝나서야 (hi nice to meet you)부분이 collect되어 합쳐진다.","categories":[{"name":"Scheme","slug":"Scheme","permalink":"https://voidsatisfaction.github.io/categories/Scheme/"},{"name":"Schemer series","slug":"Scheme/Schemer-series","permalink":"https://voidsatisfaction.github.io/categories/Scheme/Schemer-series/"}],"tags":[{"name":"Scheme","slug":"Scheme","permalink":"https://voidsatisfaction.github.io/tags/Scheme/"}],"keywords":[{"name":"Scheme","slug":"Scheme","permalink":"https://voidsatisfaction.github.io/categories/Scheme/"},{"name":"Schemer series","slug":"Scheme/Schemer-series","permalink":"https://voidsatisfaction.github.io/categories/Scheme/Schemer-series/"}]},{"title":"Nodejs 공부기 1","slug":"2016-8-23-a-nodestudy","date":"2016-08-23T02:52:00.000Z","updated":"2016-11-16T05:55:13.000Z","comments":true,"path":"2016/08/23/2016-8-23-a-nodestudy/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/23/2016-8-23-a-nodestudy/","excerpt":"","text":"선생님생활코딩 Nodejs 배운 내용들Basics Nodejs? Client and Server NPM npm init =&gt; package.json 파일 작성 npm install underscore (--save) =&gt; node_modules폴더에 underscore추가, –save는 package.json에 dependencies추가 Example : Uglify, Express, Underscore Callback Function 코드상에서 직접 호출되는 것이 아니고, 누군가가 호출하는 함수. (정의가 완벽하지 못한 것 같다.) 주로 lambda를 이용해서 구현. 함수도 데이터이기 때문에 함수가 함수를 인자로 받을 수 있는 것을 이용. Sync, Async 빨래/설거지/청소, 100만명에게 이메일 보내기 Relationship JS and Nodejs Module and NPM Structure of App.js Express API Static, Dynamic Static : html, image, … =&gt; 실시간 동기화, 편집이 쉬움 =&gt; ./public/htmlfile or img Dynamic : js code in controller(call back) =&gt; 편집은 어려우나 동적으로 제어가능 =&gt; app.js Template Engine(Jade) app.set(&#39;view engine&#39;, &#39;jade&#39;) app.set(&#39;views&#39;, &#39;./views&#39;) Jade만의 형식이 따로 있음 Query String URL을 이용한 정보의 전달 http://a.com/topic?id=1 http://a.com/topic/id/1 (semantic) Real codeApp.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const express = require('express')const app = express()app.locals.pretty = trueapp.set('view engine', 'jade')app.set('views', './views')app.use(express.static('public')) // static file serviceapp.get('/topic/:id', (req, res) =&gt; &#123; const topics = [ 'javascript is ...', 'Nodejs is ...', 'Express is ...' ] const output = ` &lt;a href=\"/topic/0\"&gt;javascript&lt;/a&gt;&lt;br&gt; &lt;a href=\"/topic/1\"&gt;nodejs&lt;/a&gt;&lt;br&gt; &lt;a href=\"/topic/2\"&gt;express&lt;/a&gt;&lt;br&gt; $&#123;topics[req.params.id]&#125; ` res.send(output)&#125;)app.get('/topic/:id/:mode', (req, res) =&gt; &#123; res.send(`$&#123;req.params.id&#125;,$&#123;req.params.mode&#125;`)&#125;)app.get('/template', (req, res) =&gt; &#123; res.render('temp', &#123;time: Date(), _title: 'jade'&#125;)&#125;)app.get('/', (req, res) =&gt; &#123; res.send('Hello this is my main page')&#125;)app.get('/dynamic', (req, res) =&gt; &#123; var lis = '' for(var i=0; i&lt;5; i++)&#123; lis += '&lt;li&gt;coding&lt;/li&gt;' &#125; var time = Date() res.send( ` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Hello Dynamic!!!! &lt;ul&gt; $&#123;lis&#125; &lt;/ul&gt; $&#123;time&#125; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ` )&#125;)app.get('/route', (req, res) =&gt; &#123; res.send('&lt;img src=\"/five_minutes.png\" /&gt;')&#125;)app.get('/login', (req, res) =&gt; &#123; res.send( `&lt;h1&gt;Practice&lt;/h1&gt; &lt;p&gt;What are you doing now?&lt;/p&gt;` )&#125;)app.listen(3000, () =&gt; &#123; console.log('Connected at 3000 port!')&#125;) Template.jade123456789html head title= _title body h1 Hello world! ul -for(var i=0; i&lt;5; i++) li coding div= time 궁금한 것들 한 컴퓨터에 여러 서버가 존재할 경우, 만일 서버의 포트가 겹치면 어떻게 되는가? 왜 콜백이 존재해야 하는가? (애초에 콜백이란 무엇인가?) maybe 중복의 제거?(기능적 중복) Ruby는 멀티스레드를 지원하는가? Nodejs는 싱글스레드인데 어떻게 비동기가 가능한 것인가?(비동기의 원리) const http = require(&#39;http&#39;) 의 정확한 의미? (http모듈 객체를 http라는 상수에 넣는다? 그럼 모듈 객체는 뭐지? 인스턴스인가?) Nodejs의 기능을 구현하기 위한 ‘그릇’ 혹은 ‘배경’ = JavaScript 라고 이해해도 되는가? RESTful? Semantic URL? Node의 View는 어떻게 꾸며주는가? Angular? Jade?","categories":[{"name":"JavaScript - Nodejs","slug":"JavaScript-Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript-Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://voidsatisfaction.github.io/tags/Nodejs/"}],"keywords":[{"name":"JavaScript - Nodejs","slug":"JavaScript-Nodejs","permalink":"https://voidsatisfaction.github.io/categories/JavaScript-Nodejs/"}]},{"title":"세상은 넓고 대단한 사람은 많다.","slug":"2016-8-21-b-justbecause","date":"2016-08-21T12:52:00.000Z","updated":"2016-09-26T15:31:06.000Z","comments":true,"path":"2016/08/21/2016-8-21-b-justbecause/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/21/2016-8-21-b-justbecause/","excerpt":"","text":"모덴 웹을 위한 Node.js프로그래밍 이라는 책을 사두기만 하고 처음 펴 봤는데 작가님의 blog가 있길래 한 번 들어가 봤다. 그랬더니 웬걸 정말 대단하신 분이다. 하하. (왜 대단하신 분인지는 블로그에 들어가 보시면 압니다.) 대놓고 얘기하자면 나도 작가님 이상이 되고싶다! 프로그래밍을 시작한지 이제 1년인데 욕심이 너무 많은거 아니냐고 생각할 수도 있지만 뭐, 이게 내가 열심히 하는 원동력이 된다고 생각한다. 그리고 수준이 너무 많이 차이난다고 생각하여 자괴감을 느낄 필요도 없다. 나는 그냥 천천히 내 생각대로 내가 하고싶은대로 하나하나 해나가야지. 힘내자! 아자아자! ^ ^","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"후배의 좋은 가르침","slug":"2016-8-21-a-learning","date":"2016-08-21T02:52:00.000Z","updated":"2016-09-26T15:30:34.000Z","comments":true,"path":"2016/08/21/2016-8-21-a-learning/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/21/2016-8-21-a-learning/","excerpt":"","text":"포인트 백엔드의 본질은 서버를 구성하는 틀을 이해하는 것이다(ex 로그인) Connecting the dots 자신이 무엇을 좋아하는지, 하고 싶은지, 잘 할 수 있는지에 대한 자기분석이 중요하고, 그것을 잘 살려 나갈 수 있어야 한다 진정한 도전정신 오늘은 후배를 만났다. 사실 그는 대학에 늦게 들어온 것 뿐이지, 컴퓨터 공학과 웹 공부에 대해서는 나에게 아주 좋은 선배다. 그 후배를 만나면 언제나 큰 자극을 받을 뿐더러 많은 것을 깨닫게 해준다. 오늘은 그 후배와의 만남에서 느낀 몇가지에 대해서 간단히 써 보려고 한다. 백엔드의 본질은 서버를 구성하는 틀을 이해하는 것이다말 그대로 후배는 웹 개발에 있어서 백엔드의 본질은 서버를 구성하는 틀을 이해하는 것이라고 했다. 서버의 구조란 Ruby On Rails를 예로 들어보면 다음과 같다. 위와 같이 Rails가 어떤 식으로 돌아가는지 Data Flow를 이해하는 것 또한 서버를 구성하는 틀을 이해하는 방식의 하나이다. 여기서 한가지 포인트는 반드시 서버 내부의 Data Flow를 이해하는 것만이 서버를 구성하는 틀을 이해하는 것이 아니라는 것이다. 서버를 다양한 각도에서 볼 수 있어야 한다. 서버를 ‘기능’의 관점에서 이해할 수도 있어야 한다. 예를들면, 서버에는 로그인, DB와의 연동 등등.. 다양한 기능이 탑재되어 있다. 이러한 ‘기능’의 시선에서 서버를 볼 줄도 알아야한다. 그리고 서버에 대한 이해가 깊어진 이후에는 각각의 상황에서 구글 선생님의 도움을 청하면 된다. Connecting the dots‘Connecting the dots’라는 말은 ‘Give it five minutes’와 더불어 내 삶의 신조와 같다. 이 말은 스티브 잡스가 스탠포드 연설에서 한 말인데, 그 뜻은 ‘지금 하는 것이 별로 도움이 되지 않는 것 처럼 보이더라도 그것이 점과 점을 연결하듯이 언젠가 무엇인가에 연결되어 도움이 될 수도 있다’ 라는 것이다.(여담이지만 스티브 잡스의 스탠포드 연설은 정말 볼 만한 가치가 있다.) 오늘 마침 후배가 자신이 참 좋아하는 말이라며 Connecting the dots에 대해서 언급했는데, 오랜만에 만난 친구를 보는 것과 같은 반가움을 느꼈다. 자신이 무엇을 좋아하는지, 하고 싶은지, 잘 할 수 있는지에 대한 자기분석이 중요하고, 그것을 잘 살려 나갈 수 있어야 한다사실 나는 이 부분이 조금 약하다고 생각한다. 물론 성격차이 일 수 있겠지만, 나는 이성적으로 냉철하게 나를 분석하고 계획을 세워서 생활하기보다는 물에 내 몸을 맡기듯이 내가 직관적으로 좋아하는 무엇인가를 자연스럽게 계속해서 추구해나가는 타입이다. 하지만 세상일들이 무릇 그렇듯 균형이 참 중요한 것 같다. 항상 직관적으로만 살아가면 냉철함을 잊기 쉽고 항상 이성적으로만 살아가면 뜨거운 열정을 잊기 쉽다. 직관과 이성의 조화가 중요하다고 생각한다. 이는 인간이나 기계나 매한가지인 듯 싶다. 직관을 배우려는 기계를 보면서 말이다. 진정한 도전정신단도직입적으로 나는 혼자서 무엇인가를 하는 것을 좋아한다. 이는, 내가 프로그래밍을 좋아하는 이유 중 하나이기도 하다. 하지만 후배는 정말 적극적으로 도전해나가는 모습이 참 멋있었다. 섬에 가서 인턴생들과 함께 기계팔을 만들어서 프로그래밍을 하거나, 스타트업에 참여해 CTO로서 적극적으로 도전해나가는 모습. 또, 그것에 그치지 않고 해커톤까지 열심히 참여하는 모습은 정말 대단하다고 느껴진다. 그래도 역시 나는 ‘나 다움’이 있다고 생각한다. 내가 혼자서 무엇인가를 하는 것을 좋아하는데 억지로 나가서 도전할 필요는 없다고 생각한다. 대신에 나 자신이 진정 도전하고 싶다는 생각이 들 때 두려움 없이 뛰쳐나갈 수 있는 마음가짐을 갖고 있는 것은 중요하다고 생각한다. 두려움과 그것을 극복할 의지. The only thing we have to fear is fear itself. 오늘 짧다면 짧고 길다면 긴 시간동안 이렇게 중요한 교훈을 느끼게 해주고 나를 한 발자국 더 나아게가 자극시켜준 후배에게 정말 감사하다는 말을 전해주고 싶다. 오늘은 기분이 참 좋은 날이다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"Local Git에서 Git Hub로 push할 경우 permission deny문제","slug":"2016-8-19-a-found","date":"2016-08-19T12:52:00.000Z","updated":"2016-09-26T15:27:29.000Z","comments":true,"path":"2016/08/19/2016-8-19-a-found/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/19/2016-8-19-a-found/","excerpt":"","text":"배경Jekyll을 로컬에서 수정하고 싶어서 Github의 repository와의 연동을 시도했으나, 다음과 같은 에러 메세지가 떴다. 포인트Local에 저장되어있는 Keychain에서, Github.com의 account와 password를 현재 사용하는 깃허브의 계정으로 변환 과정123451) Mac에서 Keychain이라는 어플리케이션을 연다.2) github.com을 검색한다.3) 속성에서 account와 password를 현 github계정으로 바꿔준다.4) 원격 저장소의 git내용에 현 저장소에는 없는 내용이 있다면 git pull origin master 로 동기화 시켜준다.5) git push origin master 깨달은 것사실 생각해보면, git과 github를 연동하기 위해서는 github의 계정정보가 로컬에 반드시 있어야 한다. 그래야만 인증이 가능하기 때문이다.그렇기 때문에, permission denied 에러가 생겼다는 것은 그 계정과 연관이 깊을 가능성이 크고, 그것을 바꿀 생각을 해야하는데 단순히 git.username git.email 만 변경한다고 해서 인증 에러를 해결할 수는 없는 것이다. 역시 본질에 입각해서 생각하면 문제의 본질을 이해할 수 있다. 참조 Permission denied error and Keychain Access GitHub::Updating credentials from the OSX Keychain GItHub::Dealing with non-fast-forward errors","categories":[{"name":"Utils","slug":"Utils","permalink":"https://voidsatisfaction.github.io/categories/Utils/"},{"name":"Git/GitHub","slug":"Utils/Git-GitHub","permalink":"https://voidsatisfaction.github.io/categories/Utils/Git-GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://voidsatisfaction.github.io/tags/GitHub/"}],"keywords":[{"name":"Utils","slug":"Utils","permalink":"https://voidsatisfaction.github.io/categories/Utils/"},{"name":"Git/GitHub","slug":"Utils/Git-GitHub","permalink":"https://voidsatisfaction.github.io/categories/Utils/Git-GitHub/"}]},{"title":"교토대 정보학과를 붙고 나서...","slug":"2016-8-19-b-graduate","date":"2016-08-19T02:52:00.000Z","updated":"2016-09-26T15:59:10.000Z","comments":true,"path":"2016/08/19/2016-8-19-b-graduate/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/19/2016-8-19-b-graduate/","excerpt":"","text":"목차 자기소개 프로그래밍의 우주에 오신 것을 환영합니다! 왜 프로그래밍을 공부하게 되었는가? 어떻게 대학원을 준비했는가? 자기소개나는 2016년 8월 현재 교토대학교 경제학부 4학년에 재학중인 학생이다. 프로그래밍을 시작한 건, 대학교 3학년 여름방학이 시작될 무렵이었다. 왜 프로그래밍을 공부하게 되었는가?내가 처음 프로그래밍을 시작하게 된 계기는 막연한 호기심과 멋 때문이었다.일본 대학의 문과계열 학생은 세미나(연구실과 비슷한 느낌입니다.)에 참가하여 지도교수님 밑에서 지도교수님의 전문분야를 학습하는데, 나와 같은 경우는 “교토식 경영”으로 한국에서도 유명하신 스에마츠 치히로 교수님 밑에서 수학하게 되었다. 내가 속한 세미나는 Logical Thinking에 대한 연구를 하며, 단순히 전문지식을 배우는 것에서 끝나지 않고, 학생들끼리 그룹 토론을 하는 경우도 많았고, 다양한 배경의 학생들의 의견을 들으며 자극도 많이 받을 수 있는 환경에 있었다. 나는 그 세미나에서 처음으로 프로그래밍을 전문적으로 하는 사람을 접하게 되었다. 웨이트 트레이닝을 매우매우 좋아하는 선배였는데(나도 그 선배와 같이 웨이트에 참여하곤 했다.), 프로그래밍을 정말로 좋아하고 프로그래밍을 즐기는 것에대한 자부심이 있는 선배였다. 그 선배는 우리는 하지 못하는 무엇인가를 항상 “창조” 했다. 예를들어, “빵집의 매상을 올리는 방법을 생각하라”라는 문제를 해결하려고 할때, 나를 비롯한 다른 학생들이 “~~한 식으로 마케팅을 하거나, 비용을 절감하면 될 것같습니다.” 라고 할 때, 그 선배는,” ~~한 시스템을 직접 만들면 어때?” 와 같은 웹 지식을 배경으로 한 보다 구체적인 방안을 제시했고, 단순히 제시만 한 것이 아니라 실현까지 하므로써 매우 설득력이 높았다. 그때부터 그 선배의 프로그래밍이라는 능력이 참 멋있어보이고 “저 선배처럼 나도 저 선배처럼 한 번 프로그래밍을 공부해봐야겠다.”라는 생각을 하게되었고, 그것이 나의 프로그래밍에 관한 모든 것의 시작이었다. 프로그래밍의 우주에 오신 것을 환영합니다!그렇게 나는 프로그래밍의 우주를 탐험하기 시작했다. 가장 처음에, 일단 어디서 프로그래밍을 공부해야하지 몰라서, 네이버에 “프로그래밍 무료 강의” 라고 검색하여 운이 좋게도 egoing님이 운영하고 계신 생활코딩 이라는 사이트를 알게 되었다.","categories":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}],"tags":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/tags/세상-사는-이야기/"}],"keywords":[{"name":"세상 사는 이야기","slug":"세상-사는-이야기","permalink":"https://voidsatisfaction.github.io/categories/세상-사는-이야기/"}]},{"title":"지킬에 관하여 알아낸 사실들","slug":"2016-8-18-a-jekyllfound","date":"2016-08-18T11:52:00.000Z","updated":"2016-09-26T15:53:58.000Z","comments":true,"path":"2016/08/18/2016-8-18-a-jekyllfound/","link":"","permalink":"https://voidsatisfaction.github.io/2016/08/18/2016-8-18-a-jekyllfound/","excerpt":"","text":"오늘 지킬에 대해서 알아낸 사실은 다음과 같다. Syntax highlight기능을 쓰기 위해서는 써야한다.12345678910112. ``` 앞뒤에 반드시 한 줄씩 띄워주어야 한다. 그렇지 않으면 잘못 인식된다.2. 내용 작성의 첫 줄은 부제목이다. 따라서 일정 길이 이상이 되면 자동으로 문법이 풀린다.3. github푸시 후 실제의 블로그에 적용되기 까지는 어느정도 시간이 필요하다### Syntax highlight기능 ###지킬에서는 하이라이트 기능으로서, Ruby의 Rough를 사용하는데, 그 사용법은\\```\\[언어명\\]\\","categories":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/tags/Ruby/"}],"keywords":[{"name":"Ruby","slug":"Ruby","permalink":"https://voidsatisfaction.github.io/categories/Ruby/"}]}]}